<!doctype html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <title>COATL</title>
    <link rel="stylesheet" href="style.css" type="text/css">
    <script>
        /*The MIT License

        Copyright (c) 2010-2018 Douglas Duhaime http://douglasduhaime.com

        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:

        The above copyright notice and this permission notice shall be included in
        all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        THE SOFTWARE.*/
        'use strict';

        /**
        * Minhash class - generates minhash signatures for set
        **/
        var Minhash = function(config) {

        // prime is the smallest prime larger than the largest
        // possible hash value (max hash = 32 bit int)
        this.prime = 4294967311;
        this.maxHash = Math.pow(2, 32) - 1;

        // initialize the hash values as the maximum value
        this.inithashvalues = function() {
            for (var i=0; i<this.numPerm; i++) {
            this.hashvalues.push(this.maxHash);
            }
        }

        // initialize the permutation functions for a & b
        // don't reuse any integers when making the functions
        this.initPermutations = function() {
            var used = {};
            for (var i=0; i<2; i++) {
            var perms = [];
            for (var j=0; j<this.numPerm; j++) {
                var int = this.randInt();
                while (used[int]) int = this.randInt();
                perms.push(int);
                used[int] = true;
            }
            var key = ['permA', 'permB'][i];
            this[key] = perms;
            }
        }

        // the update function updates internal hashvalues given user data
        this.update = function(str) {
            for (var i=0; i<this.hashvalues.length; i++) {
            var a = this.permA[i];
            var b = this.permB[i];
            var hash = (a * this.hash(str) + b) % this.prime;
            if (hash < this.hashvalues[i]) {
                this.hashvalues[i] = hash;
            }
            }
        }

        // hash a string to a 32 bit unsigned int
        this.hash = function(str) {
            var hash = 0;
            if (str.length == 0) {
            return hash + this.maxHash;
            }
            for (var i = 0; i < str.length; i++) {
            var char = str.charCodeAt(i);
            hash = ((hash<<5)-hash)+char;
            hash = hash & hash; // convert to a 32bit integer
            }
            return hash + this.maxHash;
        }

        // estimate the jaccard similarity to another minhash
        this.jaccard = function(other) {
            if (this.hashvalues.length != other.hashvalues.length) {
            throw new Error('hashvalue counts differ');
            } else if (this.seed != other.seed) {
            throw new Error('seed values differ');
            }
            var shared = 0;
            for (var i=0; i<this.hashvalues.length; i++) {
            shared += this.hashvalues[i] == other.hashvalues[i];
            }
            return shared / this.hashvalues.length;
        }

        // return a random integer >= 0 and <= maxHash
        this.randInt = function() {
            var x = Math.sin(this.seed++) * this.maxHash;
            return Math.floor((x - Math.floor(x)) * this.maxHash);
        }

        // initialize the minhash
        var config = config || {};
        this.numPerm = config.numPerm || 128;
        this.seed = config.seed || 1;
        this.hashvalues = [];
        this.permA = [];
        this.permB = [];
        // share permutation functions across all minhashes
        this.inithashvalues();
        this.initPermutations();
        };

        if (typeof window !== 'undefined') window.Minhash = Minhash;

        if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = Minhash;
        }
        exports = Minhash;
        }
    </script>
    <script>
        /**
         * A min and a max corresponding to a row of the matrix, with the first and last cells to be filled.
         * @typedef {Object} min_max_cell
         * @property {number} max
         * @property {number} min
        */
        /**
         * A matrix of numbers
         * @typedef {Array.<number[]>} matrix
        */
        /**
         * Coordinates in a dict to avoid wasting memory, in the following format : "x,y".
         * @typedef {string} coords
        */
        /**
         * A dictionary corresponding to a full Levenshtein distance matrix (without first row and first column).
         * @typedef {Object} dict - Use a 'coords' type key to access the value stored at those coordinates
         * @property {min_max_cell[]} min_max - The first and last filled cell of every row in the matrix
        */
        /**
         * A result block.
         * @typedef {Object} wordblock
         * @property {number} label - The number corresponding to the type of the block (added, removed, etc)
         * @property {string} left - The left part
         * @property {string} right - The right part
        */
        /**
         * Options pertaining to the whole alignment algorithm.
         * @typedef {Object} alignmentOptions
         * @property {boolean} punct - True if punctuation and whitespace should be compared
         * @property {boolean} typecase - True if typecase differences should be considered
        */
        /**
         * Options pertaining to the score of two blocks.
         * @typedef {Object} scoreOptions - Leave out the parameters that shouldn't be calculated (or set to null)
         * @property {number} typecase - The score added to words that are the same after typecase normalisation
         * @property {number} diacritics - The score added to words that are the same after diacritics normalisation
         * @property {number} synonymy - The score added to synonyms
         * @property {number} archaism - The score added to archaisms
         * @property {number} gender - The score added to words that are the same after gender normalisation
         * @property {number} singular - The score added to words that are the same after normalisation to the singular form
         * @property {number} tense - The score added to words that are the same after grammatical tense normalisation
         * @property {number} root - The score added to words that share the same root (general grammatical normalisation)
         * @property {number} semantics - The score added to words in the same semantic field
         * @property {number[]} scale - The scale for the Levenshtein score function. 
        */
        /**
         * A cell on the path of the make_dict_boundaries function.
         * @typedef {object} multi_scale_cell
         * @property {number} x_coord
         * @property {number} y_coord
         * @property {boolean} top_right
         * @property {boolean} bottom_left
        */

        var left_panel = document.getElementById("left_panel");
        var right_panel = document.getElementById("right_panel");
        
        /**
         * Converts number coordinates into a string key for the dictionary, used to lower memory usage at the sacrifice of speed
         * @param {number} x
         * @param {number} y
         * @returns {coords}
        */
        function dkey(x,y) {
            return (x+","+y);
        }

        /**
         * Splits a text into an array of words (includes digits, diacritics and mathematical characters).
         * @param {string} text
         * @returns {string[]}
        */
        function string_to_words(text) {
            return text.split(/[^\p{Script=Latin}]+/u).filter(block => block.length > 0); //the string is split according to the regular expression
        }
        
        /**
         * Splits a text into an array of punctuation strings (everything but letters, digits, diacritics and mathematical characters).
         * @param {string} text
         * @returns {string[]}
        */
        function string_to_punct(text) {
            return text.split(/[\p{Script=Latin}]+/u).filter(block => block.length > 0);
        }

        /**
         * Splits a text into words and punctuation.
         * @param {string} text
         * @returns {string[]}
        */
        function string_interlace(text) {
            return text.split(/([^\p{Script=Latin}]+)/u).filter(block => block.length > 0); 
        }

        /**
         * Calculates the Jaccard distance of two arrays.
         * @param {*[]} array1
         * @param {*[]} array2
         * @returns {number}
        */
        function jaccard_distance(array1, array2) {
            let m1 = new Minhash();
            let m2 = new Minhash();
            array1.map(function(w) {m1.update(w)});
            array2.map(function(w) {m2.update(w)});
            //console.log(1 - m1.jaccard(m2));
            return 1 - m1.jaccard(m2);
        }

        /**
         * Returns the length of the shortest path in a Levenshtein distance matrix of words (recursive).
         * @param {matrix} matrix
         * @param {number} x - The x-coordinate at which you enter the matrix
         * @param {number} y - The y-coordinate at which you enter the matrix
         * @param {string[]} array_x - The array of words corresponding to the x coordinate
         * @param {string[]} array_y - The array of words corresponding to the y coordinate
         * @returns {number}
        */
        function shortest_path(matrix,x,y, array_x, array_y) {
            if (x==0) return y;
            if (y==0) return x;
            let left = matrix[y][x-1];
            let top = matrix[y-1][x];
            let diag = matrix[y-1][x];
            if (left < diag) {
                if (top < left) return 1 + shortest_path(matrix,x,y-1, array_x, array_y);
                if (left < top) return 1 + shortest_path(matrix,x-1,y, array_x, array_y);
                return 1 + Math.min(shortest_path(matrix,x,y-1, array_x, array_y), shortest_path(matrix,x-1,y, array_x, array_y));
            }
            // diag <= left
            if (top < diag) return 1 + shortest_path(matrix,x,y-1, array_x, array_y);
            // diag <= top && diag <= left
            if (array_x[x-1]==array_y[y-1]) {
                return shortest_path(matrix,x-1,y-1, array_x, array_y);
            }
            // add 2 to diag
            if (diag == top) {
                if (diag == left) return Math.min(1+shortest_path(matrix,x,y-1, array_x, array_y), 1+shortest_path(matrix,x-1,y, array_x, array_y), 2+shortest_path(matrix,x-1,y-1, array_x, array_y));
                return Math.min(1+shortest_path(matrix,x,y-1, array_x, array_y), 2+shortest_path(matrix,x-1,y-1, array_x, array_y));
            }
            if (diag == left) return Math.min(1+shortest_path(matrix,x-1,y, array_x, array_y), 2+shortest_path(matrix,x-1,y-1, array_x, array_y));
            // diag < top && diag < left
            return 2+shortest_path(matrix,x-1,y-1, array_x, array_y);
        }

        /**
         * Return a value between b and a for the similarity between two strings (considered words) using Levenshtein distance.
         * @param {number} a
         * @param {number} b
         * @param {string} word1
         * @param {string} word2
         * @returns {number}
        */
        function levenshtein_score(a, b, word1, word2) {
            if (word1.length + word2.length < 6) return 1;
            let word1_array = word1.split('');
            let word2_array = word2.split('');
            let matrix = new Array(word1_array.length+1);
            for (var i=0;i<word1_array.length+1;i++) {
                matrix[i] = new Array(word2_array.length+1);
                for (var j=0;j<word2_array.length+1;j++) { 
                    if (j==0) matrix[i][0] = i;
                    else if (i==0) matrix[0][j] = j;
                    else {
                        matrix[i][j] = (word1_array[i-1]==word2_array[j-1]) ? 0 : 2;
                        matrix[i][j] = Math.min(matrix[i][j-1]+1, matrix[i-1][j]+1, matrix[i][j]+matrix[i-1][j-1]);
                    }
                }
            }
            let result = matrix[word1_array.length][word2_array.length];
            // shortest path mathematically possible : |word1.length - word2.length|
            // longest path mathematically possible : word1.length + word2.length
            // if we want a levensthein difference index between 0 and 1, we could convert it to that scale
            console.log("path length for "+word1+" & "+word2+" : "+result);
            let len_long = Math.max(word1_array.length, word2_array.length);
            let len_short = Math.min(word1_array.length, word2_array.length);
            // right now, we're using this as this yields the best results
            let return_value = (result > len_short) ? 1 : (a-b)*(result/len_short) + b;
            return return_value;
        }

        /**
         * Returns a similarity score (between 0 and 1) for the similarity between two strings (considered words) using multiple comparisons (scores are additioned if multiple comparisons are needed).
         * @param {string} word1
         * @param {string} word2
         * @param {scoreOptions} options
         * @returns {number}
        */
        function score(word1, word2, options) {
            if (word1 == word2) return 0;
            if ((("typecase" in options) && (options.typecase != null)) && (word1.toLowerCase() == word2.toLowerCase())) return options.typecase;
            if (("diacritics" in options) && (options.diacritics != null)) {
                if (word1.normalize("NFD") == word2.normalize("NFD")) return options.diacritics;
                if ((("typecase" in options) && (options.typecase != null)) && (word1.toLowerCase().normalize("NFD") == word2.toLowerCase().normalize("NFD"))) return options.typecase + options.diacritics;
                //normalisation NKFD normalise également les ligatures et formes anciennes de lettres (s long par ex.), à considérer
            }
            if (("scale" in options) && (options.scale!=null)) return levenshtein_score(options.scale[1], options.scale[0], word1.toLowerCase(), word2.toLowerCase());
            return 1;
        }

        /**
         * A grid corresponding to a Levenshtein distance matrix, both unpropagated and propagated, with the shortest path.
         * @typedef {Object} grid_display
         * @property {multi_scale_cell} path - An array of size 2 arrays representing coordinates : the shortest path from bottom right to top left.
         * @property {matrix} unpropagated
         * @property {matrix} propagated
        */
        /**
         * Fills and displays the "grid_popup" table with a path in a Levenshtein distance matrix.
         * @param {grid_display} grid_display
        */
        function show_path(grid_display) {
            let grid_popup = document.getElementById("grid_popup"); //the table div to be filled
            for (var y = 0; y < grid_display.unpropagated.length - 1; y++) {
                let new_row = document.createElement("tr"); //we create a row
                for (var x = 0; x < grid_display.unpropagated[0].length - 1; x++) {
                    let new_cell = document.createElement("td"); //we create a cell
                    new_cell.textContent = grid_display.unpropagated[y+1][x+1]; //we fill it with the corresponding score
                    new_cell.id = "x"+x+"y"+y; //we give it it's id (coordinates)
                    new_row.appendChild(new_cell); //we put the cell in the row
                }
                grid_popup.appendChild(new_row); //we put the row in the table
            }
            for (var coords of grid_display.path) { //we go through the path
                let target_cell = document.getElementById("x"+String(coords.x_coord)+"y"+String(coords.y_coord)); //the current cell in the path
                if (target_cell == null) console.log("cell null in x,y : "+coords.x_coord+","+coords.y_coord);
                target_cell.classList.add("path_cell"); //we give it the "path_cell" class to highlight it
            }
            grid_popup.style.display = "block"; //we show the table
            document.getElementById("popup_closer_button").style.display = "block"; //we show the closer button
        }
        
        /**
         * Hides the "grid_popup" table and its closer button.
        */
        function hide_path() {
            document.getElementById("grid_popup").style.display = "none";
            document.getElementById("popup_closer_button").style.display = "none";
        }

        /**
         * Aligns two text arrays and puts the scores in a dict without propagation (recursive).
         * @param {string[]} text_array1 - The full word array of text 1
         * @param {string[]} text_array2 - The full word array of text 2
         * @param {number} absolute_x - (for recursion) The starting x coordinate of the current call, set to 0 when calling externally
         * @param {number} absolute_y - (for recursion) The starting y coordinate of the current call, set to 0 when calling externally
         * @param {dict} dict - The dict to be filled
         * @param {number} min_div_size - The minimum word array size at which the recursion happens
         * @param {number} div_amount - The number of parts a word array should be divided in for recursion
         * @param {alignmentOptions} alignment_options
        */
        function align(text_array1, text_array2, absolute_x, absolute_y,dict,min_div_size,div_amount, alignment_options) {
            if (text_array1.length>min_div_size && text_array2.length>min_div_size) { //we need to divide even more before comparing words
                /** @type {grid_display} */
                let grid_display = {};
                let lvl2array1 = new Array(div_amount);
                let lvl2array2 = new Array(div_amount); //the arrays which will host the newly divided arrays
                let block_size_1 = text_array1.length/div_amount; //the average size of a block
                let block_size_2 = text_array2.length/div_amount;
                for (var j=0;j<div_amount;j++) { //the process of homogeneously dividing the arrays
                    lvl2array1[j] = text_array1.slice(Math.floor(j*block_size_1),Math.floor((j+1)*block_size_1));
                    lvl2array2[j] = text_array2.slice(Math.floor(j*block_size_2),Math.floor((j+1)*block_size_2));
                }
                //we have two arrays of the text arrays divided into 100 each, we can use them to calculate levenshtein distance as well as the best path
                /** @type {matrix} */
                let matrix = new Array(div_amount+1); //the matrix for the Levenshtein distance
                grid_display.unpropagated = new Array(div_amount+1);
                grid_display.propagated = new Array(div_amount+1);
                for (var i=0;i<div_amount+1;i++) { //filling the matrix with the basic costs (replaced by the Jaccard distance between the sets)
                    matrix[i] = new Array(div_amount+1);
                    grid_display.unpropagated[i] = new Array(div_amount+1);
                    grid_display.propagated[i] = new Array(div_amount+1);
                    for (var j=0;j<div_amount+1;j++) {
                        matrix[i][j] = (j==0) ? i : (i==0) ? j : ((i!=j) && (matrix[j] != null)) ? matrix[j][i] : jaccard_distance(lvl2array1[i-1],lvl2array2[j-1]);
                        grid_display.unpropagated[i][j] = matrix[i][j];
                        if (j==0 || i==0) grid_display.propagated[i][j] = matrix[i][j];
                        //console.log("cost before propagation in x:"+j+", y:"+i+" : "+matrix[i][j]);
                    }
                }
                //we then have the second step (cost propagation)
                for (var i=1;i<div_amount+1;i++) for (var j=1;j<div_amount+1;j++) {
                    matrix[i][j] = Math.min(matrix[i-1][j]+1, matrix[i][j-1]+1, matrix[i-1][j-1]+matrix[i][j]);
                    grid_display.propagated[i][j] = matrix[i][j];
                    //console.log("cost after propagation in x:"+j+", y:"+i+" : "+matrix[i][j]);
                }
                //we now have the full matrix for both groups of a hundred arrays, we can make out the best path and do the recursion
                /**@type {Array.<number[]>}*/
                let path = new Array();
                let x = div_amount; //the x and y coordinates to go through the matrix we just made (x for lvl2array2 and y for lvl2array1)
                let y = div_amount; //we need to lower them by 1 to access the lvl 2 arrays are they're 100 blocks long compared to the 101*101 matrix
                while (x>0 && y>0) { //while we haven't reached the top left corner
                    if (x==1) { //automatic up
                        path.push([x-1,y-1]);
                        y-=1; //we go up
                    }
                    else if (y==1) { //automatic left
                        path.push([x-1,y-1]);
                        x-=1; //we go left
                    }
                    else {
                        path.push([x-1,y-1]);
                        if (x==1 && y==1) continue;
                        let left_value = matrix[y][x-1];
                        let top_value = matrix[y-1][x];
                        let diagonal_value = matrix[y-1][x-1];   
                        if (diagonal_value <= top_value) { //diagonal <= top
                            if (diagonal_value <= left_value) { //diagonal <= top && diagonal <= left
                                x-=1;
                                y-=1; //we go in diagonal;
                            }
                            //left < diagonal <= top
                            else {
                                x-=1; //we go left
                            }
                        }
                        //top < diagonal
                        else if (left_value <= top_value) { //left <= top < diagonal
                            x-=1; //we go left, same process as before
                        }
                        //top < left < diagonal
                        else {
                            y-=1; //we go up
                        }
                    }
                }
                grid_display.path = [...path];
                show_path(grid_display);
                // our path is made, we can now align the blocks on our path and start the recursion
                x = -1;
                y = -1;
                let x_for_align = absolute_x + text_array2.length - lvl2array2[div_amount-1].length; //the absolute x and y coordinates we'll give to the descending align functions
                let y_for_align = absolute_y + text_array1.length - lvl2array1[div_amount-1].length;
                for (var coords of path) {
                    if (coords[0]==x) { //x is the same : we went up
                        y_for_align -= lvl2array1[coords[1]].length;
                    }
                    else if (coords[1]==y) { //y is the same : we went left
                        x_for_align -= lvl2array2[coords[0]].length;
                    }
                    else if (x>=0 && y>=0) { //both coords are different, we went diagonally (and we're not in the bottom right)
                        let next_x_for_align = x_for_align - lvl2array2[coords[0]].length;
                        let next_y_for_align = y_for_align - lvl2array1[coords[1]].length;
                        align(lvl2array1[y], lvl2array2[coords[0]], next_x_for_align, y_for_align, dict, min_div_size, div_amount, alignment_options);
                        align(lvl2array1[coords[1]], lvl2array2[x], x_for_align, next_y_for_align, dict, min_div_size, div_amount, alignment_options);
                        x_for_align = next_x_for_align;
                        y_for_align = next_y_for_align;
                    }
                    x = coords[0];
                    y = coords[1];
                    align(lvl2array1[y], lvl2array2[x], x_for_align, y_for_align, dict, min_div_size, div_amount, alignment_options);
                }
            }
            else { //we don't need to or cannot divide the texts more
                for (var i=0;i<text_array1.length;i++) { //filling the dict with the basic costs (0 to 1)
                    //on every y coordinate, we need to use the absolute coordinates to shift the min_max values of the dict on this line
                    dict.min_max[absolute_y+i].min = Math.min(dict.min_max[absolute_y+i].min, absolute_x);
                    dict.min_max[absolute_y+i].max = Math.max(dict.min_max[absolute_y+i].max, absolute_x+text_array2.length-1);
                    for (var j=0;j<text_array2.length;j++) { //only filling the blocks used
                        dict[dkey(absolute_x+j,absolute_y+i)] = score(text_array1[i],text_array2[j],{typecase:((alignment_options.typecase) ? 0 : 0.1), diacritics:((alignment_options.diacritics) ? 0 : 0.2)}); //if the words are the same, the cost is 0
                    }
                }
            }
        }


        // we're gonna try and split the align function in two :
            // one creates the boundaries for calculation of the dict (that's where the multi-scale algorithm happens)
            // the other one is fused with propagate, that's the values calculation

        /**
         * Divides the matrix in blocks and sets their boundaries as min and max for every line of the dict.
         * @param {string[]} text_array1 - The full word array of text 1
         * @param {string[]} text_array2 - The full word array of text 2
         * @param {dict} dict - The dict to be modified
         * @param {number} min_block_size - The size of the blocks
         * @param {number} max_matrix_size - The max size of the matrix (in number of cells)
        */
        function make_dict_boundaries(text_array1, text_array2, dict, min_block_size, max_matrix_size) {
            let div_amount_x = Math.floor(text_array2.length / min_block_size);
            let div_amount_y = Math.floor(text_array1.length / min_block_size);
            if (div_amount_x*div_amount_y > max_matrix_size) {
                div_amount_x = Math.floor(Math.sqrt(max_matrix_size));
                div_amount_y = Math.floor(Math.sqrt(max_matrix_size));
            }
            if (div_amount_x > 2 && div_amount_y > 2) {
                /** @type {grid_display} */
                let grid_display = {};
                let lvl2array1 = new Array(div_amount_y);
                let lvl2array2 = new Array(div_amount_x); //the arrays which will host the newly divided arrays
                let block_size_1 = text_array1.length/div_amount_y; //the average size of a block
                let block_size_2 = text_array2.length/div_amount_x;
                console.log("number of blocks : "+div_amount_x*div_amount_y+", minimal block size : "+min_block_size+", block y size : "+block_size_1+", block x size : "+block_size_2);
                for (var j=0;j<div_amount_x;j++) { //the process of homogeneously dividing the arrays
                    lvl2array2[j] = text_array2.slice(Math.floor(j*block_size_2),Math.floor((j+1)*block_size_2));
                }
                for (var j=0;j<div_amount_y;j++) {
                    lvl2array1[j] = text_array1.slice(Math.floor(j*block_size_1),Math.floor((j+1)*block_size_1));
                }
                //we have two arrays of the text arrays divided into 100 each, we can use them to calculate levenshtein distance as well as the best path
                /** @type {matrix} */
                let matrix = new Array(div_amount_y+1); //the matrix for the Levenshtein distance
                grid_display.unpropagated = new Array(div_amount_y+1);
                grid_display.propagated = new Array(div_amount_y+1);
                for (var i=0; i<div_amount_y+1; i++) {
                    matrix[i] = new Array(div_amount_x+1);
                    grid_display.unpropagated[i] = new Array(div_amount_x+1);
                    grid_display.propagated[i] = new Array(div_amount_x+1);
                    matrix[i][0] = i;
                    grid_display.unpropagated[i][0] = i;
                    grid_display.propagated[i][0] = i;
                }
                for (var i=1; i<div_amount_x+1; i++) {
                    matrix[0][i] = i;
                    grid_display.unpropagated[0][i] = i;
                    grid_display.propagated[0][i] = i;
                }
                for (var i=1;i<div_amount_y+1;i++) { //filling the matrix with the basic costs (replaced by the Jaccard distance between the sets)
                    for (var j=1;j<div_amount_x+1;j++) {
                        matrix[i][j] = ((i!=j) && (matrix[j] != null) && (matrix[j][i] != null)) ? matrix[j][i] : jaccard_distance(lvl2array1[i-1],lvl2array2[j-1]);
                        grid_display.unpropagated[i][j] = matrix[i][j];
                        //console.log("cost before propagation in x:"+j+", y:"+i+" : "+matrix[i][j]);
                        matrix[i][j] = Math.min(matrix[i-1][j]+1, matrix[i][j-1]+1, matrix[i-1][j-1]+matrix[i][j]);
                        grid_display.propagated[i][j] = matrix[i][j];
                        //console.log("cost after propagation in x:"+j+", y:"+i+" : "+matrix[i][j]);
                        //console.log("filled coordinates x,y : "+j+","+i+" with value "+matrix[i][j]);
                    }
                }
                //we now have the full matrix for both groups of a hundred arrays, we can make out the best path and do the recursion
                /**@type {multi_scale_cell[]}*/
                let path = new Array();
                let x = div_amount_x; //the x and y coordinates to go through the matrix we just made (x for lvl2array2 and y for lvl2array1)
                let y = div_amount_y; //we need to lower them by 1 to access the lvl 2 arrays are they're 100 blocks long compared to the 101*101 matrix
                while (x>0 && y>0) { //while we haven't reached the top left corner
                    if (x==1) { //automatic up
                        if (y==1) {
                            path.push({x_coord: x, y_coord: y-1, bottom_left: true});
                            path.push({x_coord: x-1, y_coord: y, top_right: true});
                        }
                        path.push({x_coord: x-1, y_coord: y-1});
                        y-=1; //we go up
                    }
                    else if (y==1) { //automatic left
                        path.push({x_coord: x-1, y_coord: y-1});
                        x-=1; //we go left
                    }
                    else {
                        path.push({x_coord: x-1, y_coord: y-1});
                        if (x==1 && y==1) continue;
                        let left_value = matrix[y][x-1];
                        let top_value = matrix[y-1][x];
                        let diagonal_value = matrix[y-1][x-1];   
                        if (diagonal_value <= top_value) { //diagonal <= top
                            if (diagonal_value <= left_value) { //diagonal <= top && diagonal <= left
                                if (x!=div_amount_x && y!=div_amount_y) {
                                    path.push({x_coord: x, y_coord: y-1, bottom_left: true});
                                    path.push({x_coord: x-1, y_coord: y, top_right: true});
                                }
                                x-=1;
                                y-=1; //we go in diagonal;
                            }
                            //left < diagonal <= top
                            else {
                                x-=1; //we go left
                            }
                        }
                        //top < diagonal
                        else if (left_value <= top_value) { //left <= top < diagonal
                            x-=1; //we go left, same process as before
                        }
                        //top < left < diagonal
                        else {
                            y-=1; //we go up
                        }
                    }
                }
                grid_display.path = [...path];
                show_path(grid_display);
                // our path is made, we can now set the min and max of every line
                // first we have to make an array to simplify absolute coordinates calculation
                let min_max_per_block = new Array(lvl2array2.length);
                min_max_per_block[0] = [0, lvl2array2[0].length-1];
                for (var i=1;i<lvl2array2.length;i++) min_max_per_block[i] = [min_max_per_block[i-1][1] + 1, min_max_per_block[i-1][1] + lvl2array2[i].length];
                let absolute_y_per_block = new Array(lvl2array1.length);
                absolute_y_per_block[0] = [0, lvl2array1[0].length-1];
                for (var i=1;i<lvl2array1.length;i++) absolute_y_per_block[i] = [absolute_y_per_block[i-1][1] + 1, absolute_y_per_block[i-1][1] + lvl2array1[i].length];
                for (var coords of path) {
                    for (var i = absolute_y_per_block[coords.y_coord][0]; i <= absolute_y_per_block[coords.y_coord][1]; i++) {
                        dict.min_max[i].min = Math.min(dict.min_max[i].min, min_max_per_block[coords.x_coord][0]);
                        dict.min_max[i].max = Math.max(dict.min_max[i].max, min_max_per_block[coords.x_coord][1]);
                        //console.log(i+" row min_max updated with "+dict.min_max[i].min+" - "+dict.min_max[i].max);
                    }
                    //console.log("at coords "+[...coords]+" : y from "+absolute_y_per_block[coords.y_coord][0]+" to "+absolute_y_per_block[coords.y_coord][1]+" and x from "+min_max_per_block[coords.x_coord][0]+" to "+min_max_per_block[coords.x_coord][1]);
                }

            }
        }

        /**
         * Calculates the Levenshtein distance matrix in a dict.
         * @param {string[]} text_array1 - The full word array of text 1 (y axis)
         * @param {string[]} text_array2 - The full word array of text 2 (x axis)
         * @param {dict} dict - The dict needs to have its min_max array already filled
         * @param {alignmentOptions} alignment_options
        */
        function calculate_and_propagate(text_array1, text_array2, dict, alignment_options) {
            for (var y=0;y<dict.min_max.length;y++) { //for every line of the matrix
                //console.log("check min_max : "+dict.min_max[y].min+" - "+dict.min_max[y].max);
                //if (dict.min_max[y].min = Infinity) dict.min_max[y] = {min: 0, max: text_array2.length - 1};
                for (var x = dict.min_max[y].min ; x <= dict.min_max[y].max ; x++) { //only in the existing cells
                    //console.log("cell "+y+" "+x)
                    //min(cost on the left + 1, cost on the right + 1, cost on the diagonal + 2 * current cost)
                    let left = (x==0) ? y+2 : (x==dict.min_max[y].min) ?  Infinity : dict[dkey(x-1,y)]+1;
                    let top  = (y==0) ? x+2 : (x>dict.min_max[y-1].max) ? Infinity : dict[dkey(x,y-1)]+1;
                    let diagonal = (y==0 && x==0) ? 0 : (y==0) ? x+1 : (x==0) ? y+1 : (x-1 > dict.min_max[y-1].max || x-1 < dict.min_max[y-1].min) ? Infinity : dict[dkey(x-1,y-1)]+2*(score(text_array1[y],text_array2[x],{typecase:((alignment_options.typecase) ? 0 : 0.1), diacritics:((alignment_options.diacritics) ? 0 : 0.2)}));
                    dict[dkey(x,y)] = Math.min(left,top,diagonal);
                }
            }
        }

        /**
         * Propagates the scores in a unpropagated Levenshtein distance matrix
         * @param {Object} dict - The matrix
         * @param {Object[]} dict.min_max - The array of minimal and maximal row index of each row (to avoid going through each and every absent cell), each one has a max and a min value
         * @param {number} dict.[dkey(x,y)] - The score in the cell with coords x and y
         * @returns {dict}
        */
        function propagate(dict) {
            for (var y=0;y<dict.min_max.length;y++) { //for every line of the matrix
                for (var x = dict.min_max[y].min ; x <= dict.min_max[y].max ; x++) { //only in the existing cells
                    //min(cost on the left + 1, cost on the right + 1, cost on the diagonal + 2 * current cost)
                    let left = (x==0) ? y+2 : (x==dict.min_max[y].min) ?  Infinity : dict[dkey(x-1,y)]+1;
                    let top  = (y==0) ? x+2 : (x>dict.min_max[y-1].max) ? Infinity : dict[dkey(x,y-1)]+1;
                    let diagonal = (y==0 && x==0) ? 0 : (y==0) ? x+1 : (x==0) ? y+1 : (x-1 > dict.min_max[y-1].max || x-1 < dict.min_max[y-1].min) ? Infinity : dict[dkey(x-1,y-1)]+(2*dict[dkey(x,y)]);
                    dict[dkey(x,y)] = Math.min(left,top,diagonal);
                }
            }
            return dict;
        }

        /**
         * Creates a dictionary to store a Levensthein distance matrix.
         * @param {string[]} text_array1 - Array of words
         * @param {string[]} text_array2 - Array of words
         * @param {?time} start_time - Start time of algorithm, set to null if no time should be displayed in console
         * @param {alignmentOptions} alignment_options
         * @returns {dict}
        */
        function create_dict (text_array1, text_array2, start_time, alignment_options) {
            if (start_time!=null) var dict_time = Date.now();
            var cost_dict = {};
            cost_dict.min_max = new Array(text_array1.length);
            for (var i=0;i<cost_dict.min_max.length;i++) { //pre-filling the min_max array for an easier later filling
                cost_dict.min_max[i] = {};
                cost_dict.min_max[i].min = Infinity;
                cost_dict.min_max[i].max = -Infinity;
            }
            //align(text_array1, text_array2, 0, 0, cost_dict,5000,100, alignment_options); //splits the texts into words and aligns them
            make_dict_boundaries(text_array1, text_array2, cost_dict, 50, 160000);
            if (start_time!=null) {
                console.log("time taken to make the dict boundaries : "+(Date.now()-dict_time)+" ms, total time : "+(Date.now()-start_time)+" ms");
                dict_time = Date.now();
            }
            calculate_and_propagate(text_array1, text_array2, cost_dict, alignment_options);
            //cost_dict = propagate(cost_dict);
            if (start_time!=null) {
                console.log("time taken to calculate & propagate : "+(Date.now()-dict_time)+" ms, total time : "+(Date.now()-start_time)+" ms");
            }
            //we now have the full propagated cost dictionary with min and max values for each line, allowing us to skip past empty blocks
            return cost_dict;
        }

        /**
         * The non-recursive pathmaking function, returns an array of result blocks corresponding to the best path available.
         * @param {!dict} dict - The fully propagated dictionary used
         * @param {!string[]} text_array1 - The full word array for text 1 (on the y axis)
         * @param {!string[]} text_array2 - The full word array for text 2 (on the x axis)
         * @param {alignmentOptions} alignment_options
         * @returns {wordblock[]}
        */
        function make_out_path(dict,text_array1,text_array2, alignment_options) {   
            let result_array = new Array();
            let x = text_array2.length-1;
            let y = text_array1.length-1;
            let score_options = {typecase : ((alignment_options.typecase) ? 0 : 0.1), diacritics:((alignment_options.diacritics) ? 0 : 0.2), scale:[0,0.9]};

            //we start in the bottom right corner

            while (x>=-1 && y>=-1) { // this is only to avoid errors, the while should end on the 'break;' instructions if nothing wrong happens
                //console.log("x,y : "+x+","+y);
                if (x<=-1) { //on the left-most side of the dict
                    if (y<=-1) break; //on the top left corner
                    for (var i=y;i>=0;i--) {
                        result_array.push({label:2, left:text_array1[i], right:""});
                        //console.log("up (on the left side)");
                    }
                    break;
                }
                if (y<=-1) { //on the top of the dict
                    for (var i=x;i>=0;i--) {
                        result_array.push({label:3, left:"", right:text_array2[i]});
                        //console.log("left (on the top side)");
                    }
                    break;
                }
                let diagonal_value = (dkey(x-1,y-1) in dict) ? dict[dkey(x-1,y-1)] : null;
                let left_value = (dkey(x-1,y) in dict) ? dict[dkey(x-1,y)] : null;
                let top_value = (dkey(x,y-1) in dict) ?  dict[dkey(x,y-1)] : null;

                // !!!! the following block (border) should be optimised using min_max

                if (left_value==null && top_value==null) {
                    result_array.push({label:score(text_array1[y],text_array2[x],score_options), left: text_array1[y], right:text_array2[x]});
                    x--;
                    y--;
                    //console.log("diag (in 0,0 or no left nor top square)");
                    continue;
                }
                if (left_value==null) { //we have to go up
                    result_array.push({label:2, left:text_array1[y],right:""});
                    //console.log("up (no left square)");
                    y--;
                    continue;
                }
                else if (top_value==null) { //we have to go left
                    result_array.push({label:3, left:"", right:text_array2[x]});
                    //console.log("left (no top square)");
                    x--;
                    continue;
                }
                //previous block to be restored in case of bottlenecking between diagional blocks


                // now we know we're not on a border
                if (text_array1[y]==null) console.log("error in y="+y);
                if (text_array2[x]==null) console.log("error in x="+x);
                //console.log("not on border, word1 : "+text_array1[y]+", word2 : "+text_array2[x]);
                if (diagonal_value <= left_value && diagonal_value <= top_value) {
                    let new_label = score(text_array1[y],text_array2[x],score_options); //non restricted label for further comparison
                    if (new_label<1) {
                        result_array.push({label:new_label, left: text_array1[y], right:text_array2[x]});
                        //console.log("diag (diag <= top & diag <= left & non-strict score < 1)");
                        x--;
                        y--;
                    }
                    else if (left_value < top_value) {
                        result_array.push({label:3, left:"", right:text_array2[x]});
                        //console.log("left (non-strict score >=1 and left < top)");
                        x--;
                    }
                    else {
                        result_array.push({label:2, left:text_array1[y],right:""});
                        //console.log("up (non-strict score >=1 and top <= left)");
                        y--;
                    }
                }
                else if (left_value < top_value) {
                    result_array.push({label:3, left:"", right:text_array2[x]});
                    //console.log("left (score >=1 and left < top)");
                    x--;
                }
                else {
                    result_array.push({label:2, left:text_array1[y],right:""});
                    //console.log("up (score >=1 and top <= left)");
                    y--;
                }
            }
            return result_array;
        }

        // as of now, the two following functions are useless as we have optimised the make_out_path function's pathfinding by modifying the propagate function

        //alternative tree pathmaking :
        //the tree is an object, with sets of coordinates as keys and nodes as values
        //a node is an object, with a "length" attribute (the length of the best path from this node to the end) and one to three other pairs of coordinates, to be used as keys in the tree
        //the pathmaking algorithm works like so:
        //      we check wether the keys are already in the tree with a node, if so we end the recursion
        //      we create a node in the tree with the coordinates as the key
        //      if we're in (0,0), we set the "length" attribute to 0 and end the recursion 
        //      we check the values of the three following coordinate pairs (up, left and diagonal)
        //      we reference all values with the lowest score (with keys up, left & diag)
        //      we cycle through the referenced values to apply the recursion
        //      after the recursion has been applied, we compare the lengths of the referenced nodes
        //      we modulate the diagonal node if there is one according to wether the words correspond or not (-1 if they do, +1 if they don't)
        //      we only keep the nodes with the lowest values, we delete the other ones (from the node, not from the tree)
        //      we end the recursion
        //after the tree has been made, we can go through it to create the result array :
        //      if we are in (0,0), we end the loop
        //      if there's only one node, we add the corresponding block to the result array and go to that node
        //      if not :
        //          if there's a diag key and the score of the two words is less than one, we go there
        //          else, we do a simple coordinate check to decide between left and right if the two are there
        /**
         * An object representing a node in a path tree, corresponding to coordinates in a Levenshtein distance matrix.
         * @typedef {object} node
         * @param {boolean} diag - True if the diagonal path is the shortest
         * @param {boolean} up - True if the upwards path is the shortest
         * @param {boolean} left - True if the left path is the shortest
         * @param {number} length - The length from this node to the final node (top left corner of the matrix)
        */
        /**
         * A tree representing the shortest paths from the bottom right to the top left corners of a Levenshtein distance matrix, use .
         * @typedef {object} path_tree - Use a 'coords' type key to access the node corresponding to those coordinates
        */
        /**
         * Creates the tree of the shortest paths in a Levenshtein distance matrix (recursive).
         * @param {!dict} dict - The Levenshtein distance matrix
         * @param {!path_tree} tree - Used for recursion, set to empty object when calling externally
         * @param {!number} x - Used for recursion, set to bottom right coordinate when calling externally
         * @param {!number} y - Used for recursion, set to bottom right coordinate when calling externally
         * @param {!string[]} text_array1 - The full word array for text 1 (on the y axis)
         * @param {!string[]} text_array2 - The full word array for text 2 (on the x axis)
        */
        function tree_maker(dict, tree, x, y, text_array1, text_array2) {
            if (dkey(x,y) in tree) return;
            //console.log("tree maker at x,y : "+x+","+y);
            //iter++; console.log(iter);
            if (x==-1) {
                if (y==-1) {
                    tree["-1,-1"] = {length:0};
                    return;
                }
                tree[dkey(x,y)] = {length:(1+y),up:true};
                tree_maker(dict,tree,x,y-1,text_array1,text_array2);
                return;
            }
            if (y==-1) {
                tree[dkey(x,y)] = {length:(1+x),left:true};
                tree_maker(dict,tree,x-1,y,text_array1,text_array2);
                return;
            }
            //console.log("not on dict border");
            tree[dkey(x,y)] = {};
            let current_node = tree[dkey(x,y)]; //the only variable stored inside the function call, should get rid of it if 'Maximum call stack size exceeded error' happens
            if (x==0 && y==0) {
                current_node.diag = true;
            }
            else if (!(dkey(x-1,y) in dict)) { //left is null, on border
                if (dkey(x-1,y-1) in dict) { //opportunity to go diag, we have to check
                    //console.log("up and diag");
                    if (dict[dkey(x-1,y-1)] <= dict[dkey(x-1,y)]) current_node.diag = true;
                    if (dict[dkey(x,y-1)] <= dict[dkey(x-1,y-1)]) current_node.up = true;
                }
                else { //we can only go up
                    //console.log("only up");
                    current_node.up = true;
                }
            }
            else if (!(dkey(x,y-1) in dict)) { //top is null, on border
                if (dkey(x-1,y-1) in dict) { //opportunity to go diag, we have to check
                    //console.log("left and diag");
                    if (dict[dkey(x-1,y-1)] <= dict[dkey(x,y-1)]) current_node.diag = true;
                    if (dict[dkey(x-1,y)] <= dict[dkey(x-1,y-1)]) current_node.left = true;
                }
                else { //we can only go left
                    //console.log("only left");
                    current_node.left = true;
                }
            }
            else { //neither are null, all three values are accessible
                //console.log("all 3 values accessible");
                if (dict[dkey(x-1,y-1)] <= dict[dkey(x,y-1)] && dict[dkey(x-1,y-1)] <= dict[dkey(x-1,y)]) current_node.diag = true;
                if (dict[dkey(x-1,y)] <= dict[dkey(x-1,y-1)] && dict[dkey(x-1,y)] <= dict[dkey(x,y-1)]) current_node.left = true;
                if (dict[dkey(x,y-1)] <= dict[dkey(x-1,y-1)] && dict[dkey(x,y-1)] <= dict[dkey(x-1,y)]) current_node.up = true;
            }
            //we can cycle through the values
            if ("left" in current_node) tree_maker(dict,tree,x-1,y,text_array1,text_array2);
            if ("up" in current_node) tree_maker(dict,tree,x,y-1,text_array1,text_array2);
            if ("diag" in current_node) tree_maker(dict,tree,x-1,y-1,text_array1,text_array2);
            //we can now add the length
            current_node.left_length = ("left" in current_node) ? tree[dkey(x-1,y)].length + 1 : Infinity;
            current_node.up_length = ("up" in current_node) ? tree[dkey(x,y-1)].length + 1 : Infinity;
            current_node.diag_length = ("diag" in current_node) ? ((score(text_array1[y],text_array2[x],{typecase:0.1}) < 1) ? tree[dkey(x-1,y-1)].length : tree[dkey(x-1,y-1)].length+2) : Infinity;
            current_node.length = Math.min(current_node.left_length, current_node.up_length, current_node.diag_length);
            if (current_node.left_length > current_node.length) delete current_node.left;
            if (current_node.up_length > current_node.length) delete current_node.up;
            if (current_node.diag_length > current_node.length) delete current_node.diag;
            delete current_node.left_length;
            delete current_node.diag_length;
            delete current_node.up_length;
            return;
        }

        /**
         * The alternate pathmaking function, uses tree_maker to make sure the path chosen is the best.
         * @param {!dict} dict - The Levenshtein distance matrix
         * @param {!string[]} text_array1 - The full word array for text 1 (on the y axis)
         * @param {!string[]} text_array2 - The full word array for text 2 (on the x axis)
         * @returns {wordblock[]}
        */
        function alt_make_out_path(dict, text_array1, text_array2) {
            let result_array = new Array();
            // in the result Array, 0 is unchanged, any number between 0 and 1 is changed with variations, 2 is removed (up), 3 is added (left)
            let x = text_array2.length-1;
            let y = text_array1.length-1;
            var tree = {};
            tree_maker(dict, tree, x, y, text_array1, text_array2);
            
            while (x>=-1 || y>=-1) {
                if (x<=-1 && y>=-1) break;
                //console.log("pathmaking in x,y : "+x+","+y);
                let current_node = tree[dkey(x,y)];
                if ("diag" in current_node) {
                    let new_label = score(text_array1[y],text_array2[x],{typecase:0.1,scale:[0,0.1]});
                    if (((!("left" in current_node)) && (!("up" in current_node))) || (label<1)) {
                        console.log("diag (only option or words similar)");
                        result_array.push({label:new_label, left:text_array1[y], right:text_array2[x]});
                        x--;
                        y--;
                    }
                    else if ("left" in current_node) {
                        if ("up" in current_node && y>=x) {
                            console.log("up (rather than diag, y>=x)");
                            result_array.push({label:2, left:text_array1[y], right:""});
                            y--;
                        }
                        else {
                            console.log("left (rather than diag, y<x)");
                            result_array.push({label:3, left:"", right:text_array2[x]});
                            x--;
                        }
                    }
                    else {
                        console.log("up (rather than diag, left not considered)");
                        result_array.push({label:2, left:text_array1[y], right:""});
                        y--;
                    }
                }
                else if ("up" in current_node) {
                    if ("left" in current_node && x>y) {
                        console.log("left (left = up & y<x)");
                        result_array.push({label:3, left:"", right:text_array2[x]});
                        x--;
                    }
                    else {
                        console.log("up (best option)");
                        result_array.push({label:2, left:text_array1[y], right:""});
                        y--;
                    }
                }
                else {
                    console.log("left (best option)");
                    result_array.push({label:3, left:"", right:text_array2[x]});
                    x--;
                }
            }
            return result_array;
        }

        /**
         * Fuses blocks of similar nature and adds punctuation.
         * @param {wordblock[]} text_array - The non-fused path
         * @param {string} text1 - The full first text (on the y axis)
         * @param {string} text2 - The full second text (on the x axis)
         * @returns {wordblock[]}
        */
        function bring_text_back(text_array, text1, text2) {
            /** @type {wordblock[]}*/
            let result_array = [];
            let previous_label = 4; //the variable used to know wether to create a new block or not
            let i = -1; //the index of the last block of result_array
            let punct_array_1 = text1.split(/[\p{Script=Latin}]+/u); //the first text's punctuation
            let punct_array_2 = text2.split(/[\p{Script=Latin}]+/u); //same for text 2
            //console.log(text1.split(/[\p{Script=Latin}]+/u));
            //console.log(text2.split(/[\p{Script=Latin}]+/u));
            result_array.push({label:4, left:punct_array_1[0], right:punct_array_2[0]});
            let pt_1 = 1;
            let pt_2 = 1;
            for (var block of text_array) {
                console.log("current pair : label: "+block.label+", left: "+block.left+", right: "+block.right);
                if (block.label!=previous_label) { //the current couple of words doesn't have the same label as the last, we create a new grouping
                    i++;
                    result_array.push({label:block.label, left:"", right:""});
                    console.log("should be empty :" + result_array[i].left + result_array[i].right);
                }
                previous_label=block.label;
                if (block.label!=3) { //there's a left word
                    result_array[i].left += block.left + punct_array_1[pt_1];
                    console.log("should not be empty :" + block.left);
                    pt_1++;
                }
                if (block.label!=2) { //there's a right word
                    result_array[i].right += block.right + punct_array_2[pt_2];
                    console.log("should not be empty :" + block.right);
                    pt_2++;
                }
                //console.log("current group : label: "+result_array[i].label+", left: "+result_array[i].left+", right: "+result_array[i].right);
            }
            result_array.push({label:4, left:"", right:""}); //if there's any punctuation left, we create a block for it with a punctuation label
            i++;
            if (pt_1<punct_array_1.length) result_array[i].left = punct_array_1[pt_1];
            if (pt_2<punct_array_2.length) result_array[i].right = punct_array_2[pt_2];
            return result_array;
        }

        /**
         * Fuses blocks of similar nature and adds punctuation.
         * @param {wordblock[]} text_array - The non-fused path
         * @param {string} text1 - The full first text (on the y axis)
         * @param {string} text2 - The full second text (on the x axis)
         * @param {alignmentOptions} alignment_options
         * @returns {wordblock[]}
        */
        function alt_bring_text_back(text_array, text1, text2, alignment_options) {
            /** @type {wordblock[]} */
            let result_array = new Array(0);
            if (alignment_options.punct) {
                let punct_array_1 = string_to_punct(text1); //the first text's punctuation
                let punct_array_2 = string_to_punct(text2); //same for text 2
                let pt_1 = 0;
                let pt_2 = 0;
                if (string_to_punct(string_interlace(text1)[0]).length !=0) {
                    result_array.push({label:4, left: punct_array_1[pt_1], right:""});
                    pt_1++;
                }
                if (string_to_punct(string_interlace(text2)[0]).length !=0) {
                    result_array.push({label:4, left: "", right:punct_array_2[pt_2]});
                    pt_2++;
                }
                for (var block of text_array) {
                    result_array.push(block);
                    if ((block.label != 3) && (pt_1 < punct_array_2.length)) {result_array.push({label:4, left: punct_array_1[pt_1], right:""}); pt_1++;}
                    if ((block.label != 2) && (pt_2 < punct_array_2.length)) {result_array.push({label:4, left: "", right:punct_array_2[pt_2]}); pt_2++;}
                }
                return result_array;
            }
            return text_array;
        }

        // !!!!!! currently broken, needs fixing
        /**
         * Function tied to a span, clicking on this span checks if there's a similar span on the other side (identified by id) and scrolls them both into view
         * @param {string} block_id - The id of the span, with format (l|r)_[1-9][0-9]*
        */
        function scroll_to_id(block_id) { //scrolls to a certain block id on both sides
            let left_block = document.getElementById("l_"+block_id);
            let right_block = document.getElementById("r_"+block_id);
            let left_panel = document.getElementById("left_panel");
            let right_panel = document.getElementById("right_panel");
            if (left_block!=null && right_block!=null) {
                let right_block_pos = right_block.offsetTop - (right_panel.getBoundingClientRect().height - right_block.getBoundingClientRect().height)/2;
                right_panel.scrollTo({top: right_block_pos, behavior: 'smooth'});
                let left_block_pos = left_block.offsetTop - (left_panel.getBoundingClientRect().height - left_block.getBoundingClientRect().height)/2;
                left_panel.scrollTo({top: left_block_pos, behavior: 'smooth'});
            }
        }

        /**
         * Converts a number to a class list string.
         * @param {number} typeint - 0 if unchanged, 2 if removed, 3 if added, 4 if punctuation, 1 if parallel but non corresponding, between 0 and 1 if changed
         * @returns {string}
        */
        function int_to_type(typeint) {
            if (typeint==0) return "unchanged";
            if (typeint==2) return "removed";
            if (typeint==3) return "added";
            if (typeint==4) return "punct";
            if (typeint==0.1) return "changed typecase";
            if (typeint==0.2) return "changed diacritics";
            if (typeint==0.3) return "changed typecase diacritics";
            if (typeint==1) return "non_corresponding";
            return "changed";
        }

        /**
         * Creates spans in the result display panels.
         * @param {wordblock[]} text_array - The path
        */
        function make_spans(text_array) {
            let span_id = 0;
            for (var block of text_array) {
                span_id++;
                let classes = int_to_type(block.label).split(" "); //all the classes added
                if (block.label!=3) { //create a span on the left
                    let new_span_left = document.createElement("span");
                    new_span_left.classList.add("text_part",classes);
                    new_span_left.id = "l_"+span_id; //the span id used for synchronised scrolling
                    new_span_left.textContent = block.left;
                    document.getElementById("left_panel").appendChild(new_span_left);
                }
                if (block.label!=2) { //create a span on the right
                    let new_span_right = document.createElement("span");
                    new_span_right.classList.add("text_part",classes);
                    new_span_right.id = "r_"+span_id; //the span id used for synchronised scrolling
                    new_span_right.textContent = block.right;
                    document.getElementById("right_panel").appendChild(new_span_right);
                }
                //add sync scrolling thingy
                // !!!!! broken for now
                //new_div.addEventListener("click", scroll_to_id(id,direction));
            }
        }

        /**
         * Changes the page setup to display the loading screen.
        */
        function change_to_loading_screen() {
            document.querySelectorAll("textarea").forEach(element => {
                element.style.display = "none";
            });
            document.querySelector("#align_button").style.display = "none";
            document.querySelectorAll(".checkbox_container").forEach(element => {
                element.style.display = "none"
            });
            /*let loader = document.querySelector("#loader")
            //loader.style.display = "block";
            var op = 0.1;  // initial opacity
            var timer = setInterval(function () {
                if (op >= 1){
                    clearInterval(timer);
                }
                loader.style.opacity = op;
                loader.style.filter = 'alpha(opacity=' + op * 100 + ")";
                op += op * 0.04;
            }, 10);
            delete op;
            delete timer;*/
        }

        /**
         * Changes the page setup to display the results.
        */
        function change_to_result_screen() {
            /*let loader = document.querySelector("#loader")
            var op = 1;  // initial opacity
            var timer = setInterval(function () {
                if (op <=0.1) {
                    clearInterval(timer);
                }
                loader.style.opacity = op;
                loader.style.filter = 'alpha(opacity=' + op * 100 + ")";
                op -= op * 0.06;
            }, 10);
            delete op;
            delete timer;
            loader.style.display = "none";*/
            document.querySelectorAll(".panel").forEach(element => {
                element.style.display = "block";
            });
            //document.querySelector("#reset_button").style.display = "block";
            //document.querySelector("#export_button").style.display = "block";
            
        }

        document.addEventListener("DOMContentLoaded", function(){
            console.log("DOM Content Loaded");
            //after the DOM has been loaded
            //we hide the grid display
            hide_path();
            //we add the click listener for the popup closer
            document.querySelector("#popup_closer_button").addEventListener("click",function() {
                hide_path();
            });
            /** @type {alignmentOptions} */
            var alignment_options = {
                typecase: false,
                diacritics: false,
                punct: true
            };
            document.querySelector("#punct_check").addEventListener("change", (event) => {
                if (event.currentTarget.checked) {
                    alignment_options.punct = true;
                    console.log("punct true");
                }
                else {
                    alignment_options.punct = false;
                    console.log("punct false");
                }
            });
            document.querySelector("#typecase_check").addEventListener("change", (event) => {
                if (event.currentTarget.checked) {
                    alignment_options.typecase = true;
                    console.log("typecase true");
                }
                else {
                    alignment_options.typecase = false;
                    console.log("typecase false");
                }
            });
            document.querySelector("#diacritics_check").addEventListener("change", (event) => {
                if (event.currentTarget.checked) {
                    alignment_options.diacritics = true;
                    console.log("diacritics true");
                }
                else {
                    alignment_options.diacritics = false;
                    console.log("diacritics false");
                }
            });
            //we hide the result panels
            document.querySelectorAll(".panel").forEach(element => {element.style.display = "none";});
            //we add the click listener for the align button
            document.querySelector("#align_button").addEventListener("click",function(){ //on click
                //remove visibility of button and interaction with textareas
                let start = Date.now();
                /** @type {string} */
                var left_text = document.querySelector("#left_textarea").value; //scans the left textarea
                /** @type {string} */
                var right_text = document.querySelector("#right_textarea").value; //scans the right textarea
                var ta1 = (alignment_options.punct) ? string_to_words(left_text) : string_interlace(left_text); //split the left text into words
                console.log("length of left text : "+ta1.length+" blocks");
                var ta2 = (alignment_options.punct) ? string_to_words(right_text) : string_interlace(right_text);
                console.log("length of right text : "+ta2.length+" blocks");
                if (ta1.length==0 || ta2.length==0) {
                    return;
                }
                //need an await instruction here
                change_to_loading_screen();
                var levenshtein_dict = create_dict(ta1, ta2, start, alignment_options);
                //now that we have the dict, we can do the pathmaking
                console.log("starting pathfinding");
                let path_time = Date.now();
                var path_ta = make_out_path(levenshtein_dict, ta1, ta2, alignment_options);
                console.log("time taken to make the path : " + (Date.now() - path_time) + " ms, total time : " + (Date.now() - start) + " ms");
                path_ta.reverse();
                console.log(path_ta);
                //then bring_text_back to fuse the groups and add punctuation
                path_ta = alt_bring_text_back(path_ta, left_text, right_text, alignment_options);

                // ??? add second post-treatment step to make "changed" blocks out of adjacent "removed" and "added" blocks

                //then make divs to create the divs inside of the panels
                make_spans(path_ta);
                //then we have to change page setup
                change_to_result_screen();
                console.log("result shown, total time : " + (Date.now() - start) + " ms");
            });
            document.querySelectorAll(".text_part").forEach(element => {
                var id = element.id.split('_');
                element.addEventListener("click", function() {
                    scroll_to_id(id[1],id[0]);
                });
            });
        });
    </script>
</head>
<body>
    <header>
        <div id="logo_div">
            <a href="./index.html" id="logo_anchor">
                <img width="90" height="90" src="./logoIGM-300x298.png" alt="Laboratoire d'Informatique Gaspard-Monge UMR 8049" decoding="async">
            </a>
        </div>
        <div id="titlediv">
            <h1>COATL</h1>
        </div>
        <div id="links">
            <ul id="links_list">
                <li><a href="https://siteigm.univ-mlv.fr/" target="_blank">Site du LIGM</a></li>
                <li><a href="https://github.com/maxB9F/COATL-LIGM">Dépôt Github</a></li>
            </ul>
        </div>
    </header>
    <table id="grid_popup"></table>
    <button id="popup_closer_button">Close</button>
    <div class="box" id="outerbox">
        <div class="box" id="innerbox">
            <textarea autocomplete="off" minlength="1" spellcheck="false" id="left_textarea" placeholder="La première version du texte"></textarea>
            <textarea autocomplete="off" minlength="1" spellcheck="false" id="right_textarea" placeholder="La seconde version du texte"></textarea>
            <div class="panel" id="left_panel"></div>
            <div class="panel" id="right_panel"></div>
        </div>
        <div class="box" id="button_box">
            <div class="checkbox_container">
                <input type="checkbox" id="punct_check" checked>
                <label for="punct_check">Ignorer la ponctuation et les séparateurs</label>
            </div>
            <div class="checkbox_container">
                <input type="checkbox" id="typecase_check">
                <label for="typecase_check">Ignorer les différences de casse typographique</label>
            </div>
            <div class="checkbox_container">
                <input type="checkbox" id="diacritics_check">
                <label for="diacritics_check">Ignorer les différences de signes diacritiques</label>
            </div>
            <button id="align_button"  type="button">Align</button>
            <button id="reset_button"  type="button">Reset</button>
            <button id="export_button" type="button">Export</button>
        </div>
    </div>
    <img width="150" height="149" src="./logoIGM-300x298.png" id="loader">
</body>
</html>