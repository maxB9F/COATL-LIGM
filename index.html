<!doctype html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <title>COATL</title>
    <link rel="stylesheet" href="style.css" type="text/css">
    <script src='https://cdn.jsdelivr.net/gh/duhaime/minhash@master/minhash.min.js'>
        //check license (MIT) if this is kept
    </script>
    <script>
        /*var punct_whitespace = XRegExp("[(\p{P})|(\p{Z})]+"); //all punctuation and whitespaces, one or multiple times
        var words = XRegExp("[^(\p{P})|(\p{Z})]+");*/
        var left_panel = document.getElementById("left_panel");
        var right_panel = document.getElementById("right_panel");
        function dkey(x,y) {
            return (x+","+y);
        }
        function string_to_words(text) { //splits the string into words (includes digits, diacritics and mathematical characters)
            return text.split(/[^\p{Script=Latin}]+/u); //the string is split according to the regular expression
        }
        function jaccard_distance(array1, array2) { //calculates the jaccard distance of two arrays (without taking into account multiple instances in the arrays)
            /*let set1 = new Set(array1);
            let set2 = new Set(array2);
            let intersect = new Set();
            for(var x of set1) if(set2.has(x)) intersect.add(x);
            let union = new Set(set1);
            for (var y of set2) union.add(y);
            var res = 1.0 - (intersect.length)/(union.length);
            console.log(res);
            return res;*/
            var m1 = new Minhash();
            var m2 = new Minhash();
            array1.map(function(w) {m1.update(w)});
            array2.map(function(w) {m2.update(w)});
            console.log(1 - m1.jaccard(m2));
            return 1 - m1.jaccard(m2);
        }

        /*function minHash1(array1, array2) {

        }

        function minHash100(array1, array2) { //calculates all jaccard distances between two arrays of 100 arrays of words and puts them in a dict
            let result_dict = {};
            for (var i=0;i<100;i++) {
                for (var j=i;j<100;j++) {
                    result_dict[String(i)+","+String(j)] = minHash1(array1[i],array2[i]);
                    result_dict[String(j)+","+String(i)] = result_dict[String(i)+","+String(j)];
                }
            }
            return result_dict
        }*/

        function shortest_path(matrix,x,y, array_x, array_y) {
            // recursive, returns the length of the shortest path in a levenshtein matrix
            if (x==0) return y;
            if (y==0) return x;
            let left = matrix[y][x-1];
            let top = matrix[y-1][x];
            let diag = matrix[y-1][x];
            if (left < diag) {
                if (top < left) return 1 + shortest_path(matrix,x,y-1, array_x, array_y);
                if (left < top) return 1 + shortest_path(matrix,x-1,y, array_x, array_y);
                return 1 + Math.min(shortest_path(matrix,x,y-1, array_x, array_y), shortest_path(matrix,x-1,y, array_x, array_y));
            }
            // diag <= left
            if (top < diag) return 1 + shortest_path(matrix,x,y-1, array_x, array_y);
            // diag <= top && diag <= left
            if (array_x[x-1]==array_y[y-1]) {
                return shortest_path(matrix,x-1,y-1, array_x, array_y);
            }
            // add 2 to diag
            if (diag == top) {
                if (diag == left) return Math.min(1+shortest_path(matrix,x,y-1, array_x, array_y), 1+shortest_path(matrix,x-1,y, array_x, array_y), 2+shortest_path(matrix,x-1,y-1, array_x, array_y));
                return Math.min(1+shortest_path(matrix,x,y-1, array_x, array_y), 2+shortest_path(matrix,x-1,y-1, array_x, array_y));
            }
            if (diag == left) return Math.min(1+shortest_path(matrix,x-1,y, array_x, array_y), 2+shortest_path(matrix,x-1,y-1, array_x, array_y));
            // diag < top && diag < left
            return 2+shortest_path(matrix,x-1,y-1, array_x, array_y);
        }

        function levenshtein_score(a, b, word1, word2) {
            // returns a value between b and a for the similarity between two words (or strings)
            let word1_array = word1.split('');
            let word2_array = word2.split('');
            let matrix = new Array(word1_array.length+1);
            for (var i=0;i<word1_array.length+1;i++) {
                matrix[i] = new Array(word2_array.length+1);
                for (var j=0;j<word2_array.length+1;j++) matrix[i][j] = (i==0) ? j : (j==0) ? i : (word1_array[i-1]==word2_array[j-1]) ? 0 : 1;
            }
            for (var i=1;i<word1_array.length+1;i++) {
                for (var j=1;j<word2_array.length+1;j++) {
                    matrix[i][j] = Math.max(matrix[i][j-1]+1, matrix[i-1][j]+1, matrix[i][j]+matrix[i-1][j-1]);
                }
            }
            let result = shortest_path(matrix, word2_array.length, word1_array.length, word2_array, word1_array);
            // shortest path mathematically possible : |word1.length - word2.length|
            // longest path mathematically possible : word1.length + word2.length
            // if we want a levensthein difference index between 0 and 1, we could convert it to that scale
            //console.log("path length for "+word1+" & "+word2+" : "+result);
            let len_long = Math.max(word1_array.length, word2_array.length);
            let len_short = Math.min(word1_array.length, word2_array.length);
            //right now, we're using this as this yields the best results
            let scaled = (result > len_short) ? 1 : result/len_short;
            //console.log("scaled path length for "+word1+" & "+word2+" : "+scaled);
            // we now have a number between 0 and 1, we'll convert it to a score between b and a
            return (a - b)*(scaled) + b;
        }

        function score(word1, word2, options) {
            if (word1 == word2) return 0;
            if (word1.toLowerCase() == word2.toLowerCase()) return 0.1;
            if (options != "restrict") {
                /*let word1_norm = word1.toString().normalize("NFD").replace(/\p{Diacritic}/gu, "");
                let word2_norm = word2.toString().normalize("NFD").replace(/\p{Diacritic}/gu, "");
                if (word1_norm == word1_norm) return 0.2;
                if (word1_norm.toLowerCase() == word2_norm.toLowerCase()) return 0.3;*/
                return levenshtein_score(1, 0, word1.toLowerCase(), word2.toLowerCase());
            }
            return 1;
        }

        function align(text_array1, text_array2, absolute_x, absolute_y,dict,min_div_size,div_amount) { //recursive, aligns two text arrays
            if (text_array1.length>min_div_size && text_array2.length>min_div_size) { //we need to divide even more before comparing words
                let lvl2array1 = new Array(div_amount);
                let lvl2array2 = new Array(div_amount); //the arrays which will host the newly divided arrays
                for (var j=0;j<div_amount;j++) { //the process of homogeneously dividing the arrays
                    let block_size_1 = text_array1.length/div_amount; //the average size of a block
                    let block_size_2 = text_array2.length/div_amount;
                    lvl2array1[j] = text_array1.slice(Math.floor(j*block_size_1),Math.floor((j+1)*block_size_1));
                    lvl2array2[j] = text_array2.slice(Math.floor(j*block_size_2),Math.floor((j+1)*block_size_2));
                }
                //we have two arrays of the text arrays divided into 100 each, we can use them to calculate levenshtein distance as well as the best path
                let matrix = new Array(div_amount+1); //the matrix for the Levenshtein distance
                for (var i=0;i<div_amount+1;i++) { //filling the matrix with the basic costs (replaced by the Jaccard distance between the sets)
                    matrix[i] = new Array(div_amount+1);
                    for (var j=0;j<div_amount+1;j++) {
                        matrix[i][j] = (j==0) ? i : (i==0) ? j : /*(matrix[j]) ? matrix[j][i] :*/ jaccard_distance(lvl2array1[i-1],lvl2array2[j-1]);
                        //console.log("cost before propagation in x:"+j+", y:"+i+" : "+matrix[i][j]);
                    }
                }
                //we then have the second step (cost propagation)
                for (var i=1;i<div_amount+1;i++) for (var j=1;j<div_amount+1;j++) {
                    matrix[i][j] = Math.min(matrix[i-1][j]+1, matrix[i][j-1]+1, matrix[i-1][j-1]+matrix[i][j]);
                    //console.log("cost after propagation in x:"+j+", y:"+i+" : "+matrix[i][j]);
                }
                //we now have the full matrix for both groups of a hundred arrays, we can make out the best path and do the recursion
                //to do the recursion well, we'll send the dict with it on each level, the final level (base case) will be the one actually using it
                let x = div_amount; //the x and y coordinates to go through the matrix we just made (x for lvl2array2 and y for lvl2array1)
                let y = div_amount; //we need to lower them by 1 to access the lvl 2 arrays are they're 100 blocks long compared to the 101*101 matrix
                let x_for_align = absolute_x+text_array2.length-lvl2array2[x-1].length; //the absolute x and y coordinates we'll give to the descending align functions
                let y_for_align = absolute_y+text_array1.length-lvl2array1[y-1].length;
                while (x>0 && y>0) { //while we haven't reached the top left corner
                    if (x==1) { //automatic up
                        align(lvl2array1[y-1],lvl2array2[x-1],x_for_align,y_for_align,dict,min_div_size,div_amount); //we align the block we're on
                        y-=1; //we go up
                        if (y!=0) y_for_align-=lvl2array1[y-1].length; //we shift the absolute coordinates up
                    }
                    else if (y==1) { //automatic left
                        align(lvl2array1[y-1],lvl2array2[x-1],x_for_align,y_for_align,dict,min_div_size,div_amount); //we align the block we're on
                        x-=1; //we go left
                        if (x!=0) x_for_align-=lvl2array2[x-1].length; //we shift the absolute coordinates left
                    }
                    else {
                        align(lvl2array1[y-1],lvl2array2[x-1],x_for_align,y_for_align,dict,min_div_size,div_amount); //we align the block we're on
                        if (x==1 && y==1) continue;
                        let left_value = matrix[y][x-1];
                        let top_value = matrix[y-1][x];
                        let diagonal_value = matrix[y-1][x-1];   
                        if (diagonal_value <= top_value) { //diagonal <= top
                            if (diagonal_value <= left_value) { //diagonal <= top && diagonal <= left
                                x-=1;
                                y-=1; //we go in diagonal;

                                //we will avoid bottlenecks using the following lines

                                let next_x_for_align = x_for_align - lvl2array2[x-1].length; //we shift the absolute coordinates diagonally
                                let next_y_for_align = y_for_align - lvl2array1[y-1].length;
                                align(lvl2array1[y],lvl2array2[x-1],next_x_for_align,y_for_align,dict,min_div_size,div_amount); //we align the left block
                                align(lvl2array1[y-1],lvl2array2[x],x_for_align,next_y_for_align,dict,min_div_size,div_amount); //we align the top block
                                x_for_align = next_x_for_align;
                                y_for_align = next_y_for_align;
                            }
                            //left < diagonal <= top
                            else {
                                x-=1; //we go left
                                x_for_align-=lvl2array2[x-1].length; //we shift the absolute coordinates left
                            }
                        }
                        //top < diagonal
                        else if (left_value <= top_value) { //left <= top < diagonal
                            x-=1; //we go left, same process as before
                            x_for_align-=lvl2array2[x-1].length;
                        }
                        //top < left < diagonal
                        else {
                            y-=1; //we go up
                            y_for_align-=lvl2array1[y-1].length; //we shift the absolute coordinates up
                        }
                    }
                }
            }
            else { //we don't need to or cannot divide the texts more
                for (var i=0;i<text_array1.length;i++) { //filling the dict with the basic costs (0 to 1)
                    //on every y coordinate, we need to use the absolute coordinates to shift the min_max values of the dict on this line
                    dict.min_max[absolute_y+i].min = Math.min(dict.min_max[i].min, absolute_x);
                    dict.min_max[absolute_y+i].max = Math.max(dict.min_max[i].max, absolute_x+text_array2.length-1);
                    for (var j=0;j<text_array2.length;j++) { //only filling the blocks used
                        dict[dkey(absolute_x+j,absolute_y+i)] = score(text_array1[i],text_array2[j],"restrict"); //if the words are the same, the cost is 0
                    }
                }
                //we now have a completed matrix for calculation of Levenshtein distance on a word basis
                //we still need to propagate the costs
                //we then need to make out the best path and then go through it again to display it
                //a .text_part div represents a block that's either :
                //  common to both sides (changed/unchanged), in which case there's a block on the other side with the same id
                //  unique to one of the sides (added/removed), in which case there's no block on the other side with the same id
            }
            //steps of going through the whole text :
                // start out with the bottom right coordinates
                // then, until we reach the top left :
                    // check for existence in the three neighbours
                    // pick the least costly one
                    // save the word & it's state (removed, added, changed/unchanged)
                    // change the coordinates
                // if need be, now is the time to analyse the changed words
                // we can now display the results    
        }

        //possible other way to do it : array of [levenshtein matrix, relative position to previous matrix] in order
        //to make separate code according to the direction of the next array
        //e.g. if next array is left of current array, have the least priority for "up"

        function propagate(dict) { //only to be called in create_dict
            for (var y=0;y<dict.min_max.length;y++) { //for every line of the matrix
                for (var x = dict.min_max[y].min ; x <= dict.min_max[y].max ; x++) { //only in the used blocks
                    //min(cost on the left + 1, cost on the right + 1, cost on the diagonal + current cost)
                    let left = (x==0) ? y+2 : (x==dict.min_max[y].min) ?  Infinity : dict[dkey(x-1,y)]+1;
                    let top  = (y==0) ? x+2 : (x>dict.min_max[y-1].max) ? Infinity : dict[dkey(x,y-1)]+1;
                    let diagonal = (y==0 && x==0) ? 0 : (y==0) ? x+1 : (x==0) ? y+1 : (x-1 > dict.min_max[y-1].max || x-1 < dict.min_max[y-1].min) ? Infinity : dict[dkey(x-1,y-1)]+dict[dkey(x,y)];
                    dict[dkey(x,y)] = Math.min(left,top,diagonal);
                }
            }
            return dict;
        }

        function create_dict (text_array1, text_array2, start_time) {
            if (start_time!=null) var dict_time = Date.now();
            var cost_dict = {};
            cost_dict.min_max = new Array(text_array1.length);
            for (var i=0;i<cost_dict.min_max.length;i++) { //pre-filling the min_max array for an easier later filling
                cost_dict.min_max[i] = {};
                cost_dict.min_max[i].min = Infinity;
                cost_dict.min_max[i].max = -Infinity;
            }
            align(text_array1, text_array2, 0, 0, cost_dict,1000,100); //splits the texts into words and aligns them
            if (start_time!=null) {
                console.log("time taken to make the dict : "+(Date.now()-dict_time)+" ms, total time : "+(Date.now()-start_time)+" ms");
                dict_time = Date.now();
            }
            //now we have the dict with costs between 0 and 1, we need to propagate before returning it
            cost_dict = propagate(cost_dict);
            if (start_time!=null) {
                console.log("time taken to propagate : "+(Date.now()-dict_time)+" ms, total time : "+(Date.now()-start_time)+" ms");
                delete dict_time;
            }
            //we now have the full propagated cost dictionary with min and max values for each line, allowing us to skip past empty blocks
            return cost_dict;
        }

        function make_out_path(dict,text_array1,text_array2) { //returns array of couples (size 2 arrays) of strings
            let result_array = new Array();
            // in the result Array, 0 is unchanged, any number between 0 and 1 is changed with variations, 2 is removed, 3 is added
            let x = text_array2.length-1;
            let y = text_array1.length-1;
            var previous_direction = 0; //none, 1=up, 2=left, 3=diagonal (binary)
            while (x>=-1 && y>=-1) {
                //console.log("x,y : "+x+","+y);
                if (x<=-1) { //on the left-most side of the dict
                    if (y<=-1) break; //on the top left corner
                    for (var i=y;i>=0;i--) {
                        result_array.push([2, text_array1[i],""]);
                        //console.log("up (on the left side)");
                    }
                    break;
                }
                if (y<=-1) { //on the top of the dict
                    for (var i=x;i>=0;i--) {
                        result_array.push([3, "",text_array2[i]]);
                        //console.log("left (on the top side)");
                    }
                    break;
                }
                let current_key = String(x)+","+String(y); //the four used coordinate keys
                let diagonal_key = String(x-1)+","+String(y-1);
                let left_key = String(x-1)+","+String(y);
                let top_key = String(x)+","+String(y-1);
                let diagonal_value = null;
                let left_value = null;
                let top_value = null;
                if (diagonal_key in dict) {diagonal_value = dict[diagonal_key];}
                if (left_key in dict) {left_value = dict[left_key];}
                if (top_key in dict) {top_value = dict[top_key];}
                if (left_value==null || top_value==null) { //on a border
                    if (x==0 && y==0) {
                        let label = score(text_array1[y],text_array2[x]);
                        result_array.push([label, text_array1[y],text_array2[x]]);
                        //console.log("diag (in 0,0)");
                        break;
                    }
                    if (left_value==null) { //we have to go up
                        previous_direction = 1;
                        result_array.push([2, text_array1[y],""]);
                        //console.log("up (no left square)");
                        y--;
                    }
                    else { //we have to go left
                        previous_direction = 2;
                        result_array.push([3, "",text_array2[x]]);
                        //console.log("left (no top square)");
                        x--;
                    }
                    continue;
                }
                // now we know we're not on a border
                if (text_array1[y]==null) console.log("error in y="+y);
                if (text_array2[x]==null) console.log("error in x="+x);
                //console.log("not on border, word1 : "+text_array1[y]+", word2 : "+text_array2[x]);
                let label = score(text_array1[y],text_array2[x],"restrict");

                if (label<1) { //same word or slight change, we go diagonally
                    result_array.push([label, text_array1[y],text_array2[x]]);
                    //console.log("diag (strict score < 1)");
                    x--;
                    y--;
                }
                else if (diagonal_value <= left_value && diagonal_value <= top_value) {
                    let label = score(text_array1[y],text_array2[x],null);
                    if (label<1) {
                        result_array.push([label, text_array1[y],text_array2[x]]);
                        //console.log("diag (diag <= top & diag <= left & non-strict score < 1)");
                        x--;
                        y--;
                    }
                    else if (left_value < top_value) {
                        previous_direction = 2;
                        result_array.push([3, "",text_array2[x]]);
                        //console.log("left (non-strict score >=1 and left < top)");
                        x--;
                    }
                    else {
                        previous_direction = 1;
                        result_array.push([2, text_array1[y],""]);
                        //console.log("up (non-strict score >=1 and top <= left)");
                        y--;
                    }
                }
                else if (left_value < top_value) {
                    previous_direction = 2;
                    result_array.push([3, "",text_array2[x]]);
                    //console.log("left (score >=1 and left < top)");
                    x--;
                }
                else {
                    previous_direction = 1;
                    result_array.push([2, text_array1[y],""]);
                    //console.log("up (score >=1 and top <= left)");
                    y--;
                }
                /*
                else if (left_value < top_value) {
                    if (left_value < diagonal_value) {
                        previous_direction = 2;
                        result_array.push([3, "",text_array2[x]]);
                        //console.log("left (least costly)");
                        x--;
                    }
                    else if (left_value == diagonal_value) {
                        let label = score(text_array1[y],text_array2[x]);
                        if (label>1) {
                            previous_direction = 2;
                            result_array.push([3, "",text_array2[x]]);
                            //console.log("left (left = diag < top & score > 1)");
                            x--;
                        }
                        else {
                            result_array.push([label, text_array1[y],text_array2[x]]);
                            //console.log("diag (diag = left < top & score <= 1)");
                            x--;
                            y--;
                        }
                    }
                    else {
                        let label = score(text_array1[y],text_array2[x]);
                        result_array.push([label, text_array1[y],text_array2[x]]);
                        //console.log("diag (least costly))");
                        x--;
                        y--;
                    }
                }
                // top <= left
                else if (top_value < left_value) {
                    if (top_value < diagonal_value) {
                        previous_direction = 1;
                        result_array.push([2, text_array1[y],""]);
                        //console.log("up (least costly)");
                        y--;
                    }
                    else if (top_value == diagonal_value) {
                        let label = score(text_array1[y],text_array2[x]);
                        if (label>1) {
                            previous_direction = 1;
                            result_array.push([2, text_array1[y],""]);
                            //console.log("up (top = diag < left & score > 1)");
                            y--;
                        }
                        else {
                            result_array.push([label, text_array1[y],text_array2[x]]);
                            //console.log("diag (diag = top < left & score <= 1)");
                            x--;
                            y--;
                        }
                    }
                    else {
                        let label = score(text_array1[y],text_array2[x]);
                        result_array.push([label, text_array1[y],text_array2[x]]);
                        //console.log("diag (least costly))");
                        x--;
                        y--;
                    }
                }
                // top = left
                else if (diagonal_value < top_value) {
                    let label = score(text_array1[y],text_array2[x]);
                    result_array.push([label, text_array1[y],text_array2[x]]);
                    //console.log("diag (least costly))");
                    x--;
                    y--;
                }
                // top = left = diagonal
                else {
                    let label = score(text_array1[y],text_array2[x]);
                    if (label<=1) {
                        result_array.push([label, text_array1[y],text_array2[x]]);
                        //console.log("diag (same cost & score <= 1))");
                        x--;
                        y--;
                    }
                    else if (previous_direction==1) {
                        result_array.push([2, text_array1[y],""]);
                        //console.log("up (same cost, score > 1 and went up before)");
                        y--;
                    }
                    else if (previous_direction==2) {
                        result_array.push([3, "",text_array2[x]]);
                        //console.log("left (same cost, score > 1 and went left before)");
                        x--;
                    }
                    else if (x<y) {
                        previous_direction = 2;
                        result_array.push([3, "",text_array2[x]]);
                        //console.log("left (first square, no choice and x<y)");
                        x--;
                    }
                    else {
                        previous_direction = 3;
                        result_array.push([3, "",text_array2[x]]);
                        //console.log("left (first square, no choice and x>=y)");
                        x--;
                    }
                }
                */
            }
            return result_array;
        }
        var iter = 0;
        //alternative tree pathmaking :
        //the tree is an object, with sets of coordinates as keys and nodes as values
        //a node is an object, with a "length" attribute (the length of the best path from this node to the end) and one to three other pairs of coordinates, to be used as keys in the tree
        //the pathmaking algorithm works like so:
        //      we check wether the keys are already in the tree with a node, if so we end the recursion
        //      we create a node in the tree with the coordinates as the key
        //      if we're in (0,0), we set the "length" attribute to 0 and end the recursion 
        //      we check the values of the three following coordinate pairs (up, left and diagonal)
        //      we reference all values with the lowest score (with keys up, left & diag)
        //      we cycle through the referenced values to apply the recursion
        //      after the recursion has been applied, we compare the lengths of the referenced nodes
        //      we modulate the diagonal node if there is one according to wether the words correspond or not (-1 if they do, +1 if they don't)
        //      we only keep the nodes with the lowest values, we delete the other ones (from the node, not from the tree)
        //      we end the recursion
        //after the tree has been made, we can go through it to create the result array :
        //      if we are in (0,0), we end the loop
        //      if there's only one node, we add the corresponding block to the result array and go to that node
        //      if not :
        //          if there's a diag key and the score of the two words is less than one, we go there
        //          else, we do a simple coordinate check to decide between left and right if the two are there
        function tree_maker(dict, tree, x, y, text_array1, text_array2) {
            if (dkey(x,y) in tree) return;
            iter++;
            console.log(iter);
            //console.log("tree maker at x,y : "+x+","+y);
            if (x==-1) {
                if (y==-1) {
                    tree["-1,-1"] = {length:0};
                    return;
                }
                tree[dkey(x,y)] = {length:(1+y),up:true};
                tree_maker(dict,tree,x,y-1,text_array1,text_array2);
                return;
            }
            if (y==-1) {
                tree[dkey(x,y)] = {length:(1+x),left:true};
                tree_maker(dict,tree,x-1,y,text_array1,text_array2);
                return;
            }
            //console.log("not on dict border");
            tree[dkey(x,y)] = {};
            let current_node = tree[dkey(x,y)]; //the only variable stored inside the function call, should get rid of it if 'Maximum call stack size exceeded error' happens
            if (x==0 && y==0) {
                current_node.diag = true;
            }
            else if (!(dkey(x-1,y) in dict)) { //left is null, on border
                if (dkey(x-1,y-1) in dict) { //opportunity to go diag, we have to check
                    //console.log("up and diag");
                    if (dict[dkey(x-1,y-1)] <= dict[dkey(x-1,y)]) current_node.diag = true;
                    if (dict[dkey(x,y-1)] <= dict[dkey(x-1,y-1)]) current_node.up = true;
                }
                else { //we can only go up
                    //console.log("only up");
                    current_node.up = true;
                }
            }
            else if (!(dkey(x,y-1) in dict)) { //top is null, on border
                if (dkey(x-1,y-1) in dict) { //opportunity to go diag, we have to check
                    //console.log("left and diag");
                    if (dict[dkey(x-1,y-1)] <= dict[dkey(x,y-1)]) current_node.diag = true;
                    if (dict[dkey(x-1,y)] <= dict[dkey(x-1,y-1)]) current_node.left = true;
                }
                else { //we can only go left
                    //console.log("only left");
                    current_node.left = true;
                }
            }
            else { //neither are null, all three values are accessible
                //console.log("all 3 values accessible");
                if (dict[dkey(x-1,y-1)] <= dict[dkey(x,y-1)] && dict[dkey(x-1,y-1)] <= dict[dkey(x-1,y)]) current_node.diag = true;
                if (dict[dkey(x-1,y)] <= dict[dkey(x-1,y-1)] && dict[dkey(x-1,y)] <= dict[dkey(x,y-1)]) current_node.left = true;
                if (dict[dkey(x,y-1)] <= dict[dkey(x-1,y-1)] && dict[dkey(x,y-1)] <= dict[dkey(x-1,y)]) current_node.up = true;
            }
            //we can cycle through the values
            if ("left" in current_node) tree_maker(dict,tree,x-1,y,text_array1,text_array2);
            if ("up" in current_node) tree_maker(dict,tree,x,y-1,text_array1,text_array2);
            if ("diag" in current_node) tree_maker(dict,tree,x-1,y-1,text_array1,text_array2);
            //we can now add the length
            current_node.left_length = ("left" in current_node) ? tree[dkey(x-1,y)].length + 1 : Infinity;
            current_node.up_length = ("up" in current_node) ? tree[dkey(x,y-1)].length + 1 : Infinity;
            current_node.diag_length = ("diag" in current_node) ? ((score(text_array1[y],text_array2[x]) < 1) ? tree[dkey(x-1,y-1)].length : tree[dkey(x-1,y-1)].length+2) : Infinity;
            current_node.length = Math.min(current_node.left_length, current_node.up_length, current_node.diag_length);
            if (current_node.left_length > current_node.length) delete current_node.left;
            if (current_node.up_length > current_node.length) delete current_node.up;
            if (current_node.diag_length > current_node.length) delete current_node.diag;
            delete current_node.left_length;
            delete current_node.diag_length;
            delete current_node.up_length;
            return;
        }

        function alt_make_out_path(dict, text_array1, text_array2) {
            let result_array = new Array();
            // in the result Array, 0 is unchanged, any number between 0 and 1 is changed with variations, 2 is removed (up), 3 is added (left)
            let x = text_array2.length-1;
            let y = text_array1.length-1;
            var tree = {};
            tree_maker(dict, tree, x, y, text_array1, text_array2);
            
            while (x>=-1 || y>=-1) {
                if (x<=-1 && y>=-1) break;
                //console.log("pathmaking in x,y : "+x+","+y);
                let current_node = tree[dkey(x,y)];
                if ("diag" in current_node) {
                    let label = score(text_array1[y],text_array2[x]);
                    if (((!("left" in current_node)) && (!("up" in current_node))) || (label<1)) {
                        console.log("diag (only option or words similar)");
                        result_array.push([label,text_array1[y],text_array2[x]]);
                        x--;
                        y--;
                    }
                    else if ("left" in current_node) {
                        if ("up" in current_node && y>=x) {
                            console.log("up (rather than diag, y>=x)");
                            result_array.push([2,text_array1[y],""]);
                            y--;
                        }
                        else {
                            result_array.push([3,"",text_array2[x]]);
                            console.log("left (rather than diag, y<x)");
                            x--;
                        }
                    }
                    else {
                        console.log("up (rather than diag, left not considered)");
                        result_array.push([2,text_array1[y],""]);
                        y--;
                    }
                }
                else if ("up" in current_node) {
                    if ("left" in current_node && x>y) {
                        console.log("left (left = up & y<x)");
                        result_array.push([3,"",text_array2[x]]);
                        x--;
                    }
                    else {
                        console.log("up (best option)");
                        result_array.push([2,text_array1[y],""]);
                        y--;
                    }
                }
                else {
                    console.log("left (best option)");
                    result_array.push([3,"",text_array2[x]]);
                    x--;
                }
            }
            delete tree;
            return result_array;
        }

        function bring_text_back(text_array, text1, text2) { //fuses strings of similar nature and adds punctuation
            let result_array = [];
            let previous_label = -1; //the variable used to know wether to create a new block or not
            let i = -1; //the index of the last block of result_array
            let punct_array_1 = text1.split(/[\p{Script=Latin}]+/u); //the first text's punctuation
            let punct_array_2 = text2.split(/[\p{Script=Latin}]+/u); //same for text 2
            let pt_1 = 1; //the first element of the arrays is always '' (empty string)
            let pt_2 = 1;
            for (var block of text_array) {
                if (block[0]!=previous_label) { //the current couple of words doesn't have the same label as the last, we create a new grouping
                    i++;
                    result_array.push([block[0],"",""]);
                }
                previous_label=block[0];
                if (block[0]!=3) { //there's a left word
                    result_array[i][1] = result_array[i][1].concat(block[1],punct_array_1[pt_1]);
                    pt_1++;
                }
                if (block[0]!=2) { //there's a right word
                    result_array[i][2] = result_array[i][2].concat(block[2],punct_array_2[pt_2]);
                    pt_2++;
                }
            }
            let last_punct = [4,null,null]; //if there's any punctuation left, we create a block for it with a unique label
            if (pt_1<punct_array_1.length) last_punct[0] = punct_array_1[pt_1];
            if (pt_2<punct_array_2.length) last_punct[1] = punct_array_2[pt_2];
            if (last_punct[0]!=null || last_punct[1]!=null) result_array.push(last_punct);
            return result_array;
        }

        function scroll_to_id(block_id, direction) { //scrolls to a certain block id on both sides
            let left_block = document.getElementById("l_"+block_id);
            let right_block = document.getElementById("r_"+block_id);
            let left_panel = document.getElementById("left_panel");
            let right_panel = document.getElementById("right_panel");
            if (left_block!=null && right_block!=null) {
                var right_block_pos = right_block.offsetTop - (right_panel.getBoundingClientRect().height - right_block.getBoundingClientRect().height)/2;
                right_panel.scrollTo({top: right_block_pos, behavior: 'smooth'});
                var left_block_pos = left_block.offsetTop - (left_panel.getBoundingClientRect().height - left_block.getBoundingClientRect().height)/2;
                left_panel.scrollTo({top: left_block_pos, behavior: 'smooth'});
            }
        }

        function int_to_type(typeint) {
            if (typeint==0) return "unchanged";
            if (typeint==2) return "removed";
            if (typeint==3) return "added";
            if (typeint==4) return "punct";
            if (typeint==0.1) return "changed typecase";
            if (typeint==0.2) return "changed diacritics";
            if (typeint==0.3) return "changed typecase diacritics";
            if (typeint==1) return "non_corresponding"
            return "changed";
        }

        function make_spans(text_array) {
            let span_id = 0;
            for (var block of text_array) {
                let classes = int_to_type(block[0]).split(" "); //all the classes added
                if (block[0]!=3) { //create a span on the left
                    let new_span_left = document.createElement("span");
                    new_span_left.classList.add("text_part",classes);
                    new_span_left.id = "l_"+String(span_id); //the span id used for synchronised scrolling
                    new_span_left.textContent = block[1];
                    document.getElementById("left_panel").appendChild(new_span_left);
                }
                if (block[0]!=2) { //create a span on the right
                    let new_span_right = document.createElement("span");
                    new_span_right.classList.add("text_part",classes);
                    new_span_right.id = "r_"+String(span_id); //the span id used for synchronised scrolling
                    new_span_right.textContent = block[2];
                    document.getElementById("right_panel").appendChild(new_span_right);
                }
                //add sync scrolling thingy
                // !!!!! broken for now
                //new_div.addEventListener("click", scroll_to_id(id,direction));
                span_id++;
            }
        }

        function change_to_loading_screen() {
            document.querySelectorAll("textarea").forEach(element => {
                element.style.display = "none";
            });
            document.querySelector("#align_button").style.display = "none";
            let loader = document.querySelector("#loader")
            //loader.style.display = "block";
            var op = 0.1;  // initial opacity
            var timer = setInterval(function () {
                if (op >= 1){
                    clearInterval(timer);
                }
                loader.style.opacity = op;
                loader.style.filter = 'alpha(opacity=' + op * 100 + ")";
                op += op * 0.04;
            }, 10);
        }

        function change_to_result_screen() {
            let loader = document.querySelector("#loader")
            var op = 1;  // initial opacity
            var timer = setInterval(function () {
                if (op <=0.1){
                clearInterval(timer);
            }
            loader.style.opacity = op;
            loader.style.filter = 'alpha(opacity=' + op * 100 + ")";
            op -= op * 0.06;
            }, 10);
            loader.style.display = "none";
            document.querySelectorAll(".panel").forEach(element => {
                element.style.display = "block";
            });
            document.querySelector("#reset_button").style.display = "block";
            document.querySelector("#export_button").style.display = "block";
        }

        document.addEventListener("DOMContentLoaded", function(){
            //after the DOM has been loaded
            //we hide the result panels
            document.querySelectorAll(".panel").forEach(element => {element.style.display = "none";});
            //we add the click listener for the align button
            document.querySelector("#align_button").addEventListener("click",function(){ //on click
                //remove visibility of button and interaction with textareas
                change_to_loading_screen();
                //setTimeout(function(){
                    let start = Date.now();
                    var left_text = document.querySelector("#left_textarea").value; //scans the left textarea
                    var right_text = document.querySelector("#right_textarea").value; //scans the right textarea
                    var ta1 = string_to_words(left_text);
                    ta1.pop();
                    console.log("length of left text : "+ta1.length+" words");
                    var ta2 = string_to_words(right_text);
                    ta2.pop();
                    console.log("length of right text : "+ta2.length+" words");
                    var levenshtein_dict = create_dict(ta1, ta2, start);
                    //now that we have the dict, we can use make_out_path
                    let path_time = Date.now();
                    var path_ta = make_out_path(levenshtein_dict, ta1, ta2);
                    console.log("time taken to make the path : " + (Date.now() - path_time) + " ms, total time : " + (Date.now() - start) + " ms");
                    path_ta.reverse();
                    console.log(path_ta);
                    //then bring_text_back to fuse the groups and add punctuation
                    path_ta = bring_text_back(path_ta, left_text, right_text);

                    // ??? add second post-treatment step to make "changed" blocks out of adjacent "removed" and "added" blocks

                    //then make divs to create the divs inside of the panels
                    make_spans(path_ta);
                    //then we have to change page setup
                    change_to_result_screen();
                    console.log("result shown, total time : " + (Date.now() - start) + " ms");
                    //tadaaaaaa
                //}, 10);
            });
            document.querySelectorAll(".text_part").forEach(element => {
                var id = element.id.split('_');
                element.addEventListener("click", function() {
                    scroll_to_id(id[1],id[0]);
                });
                delete id;
            });
            document.querySelector("#reset_button").addEventListener("click",function(){
                delete levenshtein_dict;
                delete ta1;
                delete ta2;
                delete left_text;
                delete right_text;
                delete path_ta;
            });
        });
    </script>
</head>
<body>
    <header>
        <div id="logo_div">
            <a href="./index.html" id="logo_anchor">
                <img width="286" height="120" src="https://siteigm.univ-mlv.frr/wp-content/uploads/2021/10/LIGM-CMJN-couleurs-300dpi-1.png" alt="Laboratoire d'Informatique Gaspard-Monge UMR 8049" decoding="async">
            </a>
        </div>
        <div id="titlediv">
            <h1>nom de l'outil (à déterminer)</h1>
        </div>
        <div id="links">
            <ul id="links_list">
                <li><a href="https://siteigm.univ-mlv.fr/" target="_blank">Site du LIGM</a></li>
                <li>à propos du site</li>
                <li>english version</li>
            </ul>
        </div>
    </header>
    <div class="box" id="outerbox">
        <div class="box" id="innerbox">
            <textarea autocomplete="off" minlength="1" spellcheck="false" id="left_textarea" placeholder="La première version du texte"></textarea>
            <textarea autocomplete="off" minlength="1" spellcheck="false" id="right_textarea" placeholder="La seconde version du texte"></textarea>
            <div class="panel" id="left_panel"></div>
            <div class="panel" id="right_panel"></div>
        </div>
        <div class="box" id="button_box">
            <button id="align_button"  type="button">Align</button>
            <button id="reset_button"  type="button">Reset</button>
            <button id="export_button" type="button">Export</button>
        </div>
    </div>
    <footer>(nom de l'outil) (contact: insérer mailto:)
    </footer>
    <img width="150" height="149" src="./logoIGM-300x298.png" id="loader">
</body>
</html>