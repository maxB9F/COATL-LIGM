<!doctype html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <!--
    COATL - Alignment Tool for Litterary (or other) texts.
    Copyright (C) 2023 Maxime Kremer

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
    -->
    <title>COATL</title>
    <link rel="stylesheet" href="style.css" type="text/css">
    <script>
        /*The MIT License

        Copyright (c) 2010-2018 Douglas Duhaime http://douglasduhaime.com

        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:

        The above copyright notice and this permission notice shall be included in
        all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        THE SOFTWARE.*/
        'use strict';

        /**
        * Minhash class - generates minhash signatures for set
        **/
        var Minhash = function(config) {

        // prime is the smallest prime larger than the largest
        // possible hash value (max hash = 32 bit int)
        this.prime = 4294967311;
        this.maxHash = Math.pow(2, 32) - 1;

        // initialize the hash values as the maximum value
        this.inithashvalues = function() {
            for (var i=0; i<this.numPerm; i++) {
            this.hashvalues.push(this.maxHash);
            }
        }

        // initialize the permutation functions for a & b
        // don't reuse any integers when making the functions
        this.initPermutations = function() {
            var used = {};
            for (var i=0; i<2; i++) {
            var perms = [];
            for (var j=0; j<this.numPerm; j++) {
                var int = this.randInt();
                while (used[int]) int = this.randInt();
                perms.push(int);
                used[int] = true;
            }
            var key = ['permA', 'permB'][i];
            this[key] = perms;
            }
        }

        // the update function updates internal hashvalues given user data
        this.update = function(str) {
            for (var i=0; i<this.hashvalues.length; i++) {
            var a = this.permA[i];
            var b = this.permB[i];
            var hash = (a * this.hash(str) + b) % this.prime;
            if (hash < this.hashvalues[i]) {
                this.hashvalues[i] = hash;
            }
            }
        }

        // hash a string to a 32 bit unsigned int
        this.hash = function(str) {
            var hash = 0;
            if (str.length == 0) {
            return hash + this.maxHash;
            }
            for (var i = 0; i < str.length; i++) {
            var char = str.charCodeAt(i);
            hash = ((hash<<5)-hash)+char;
            hash = hash & hash; // convert to a 32bit integer
            }
            return hash + this.maxHash;
        }

        // estimate the jaccard similarity to another minhash
        this.jaccard = function(other) {
            if (this.hashvalues.length != other.hashvalues.length) {
            throw new Error('hashvalue counts differ');
            } else if (this.seed != other.seed) {
            throw new Error('seed values differ');
            }
            var shared = 0;
            for (var i=0; i<this.hashvalues.length; i++) {
            shared += this.hashvalues[i] == other.hashvalues[i];
            }
            return shared / this.hashvalues.length;
        }

        // return a random integer >= 0 and <= maxHash
        this.randInt = function() {
            var x = Math.sin(this.seed++) * this.maxHash;
            return Math.floor((x - Math.floor(x)) * this.maxHash);
        }

        // initialize the minhash
        var config = config || {};
        this.numPerm = config.numPerm || 128;
        this.seed = config.seed || 1;
        this.hashvalues = [];
        this.permA = [];
        this.permB = [];
        // share permutation functions across all minhashes
        this.inithashvalues();
        this.initPermutations();
        };

        if (typeof window !== 'undefined') window.Minhash = Minhash;

        if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = Minhash;
        }
        exports = Minhash;
        }
    </script>
    <script>
        /**
         * A min and a max corresponding to a row of the matrix, with the first and last cells to be filled.
         * @typedef {Object} min_max_cell
         * @property {number} max
         * @property {number} min
        */
        /**
         * A matrix of numbers
         * @typedef {Array.<number[]>} matrix
        */
        /**
         * Coordinates in a dict to avoid wasting memory, in the following format : "x,y".
         * @typedef {string} coords
        */
        /**
         * A dictionary corresponding to a full Levenshtein distance matrix (without first row and first column).
         * @typedef {Object} dict - Use a 'coords' type key to access the value stored at those coordinates
         * @property {min_max_cell[]} min_max - The first and last filled cell of every row in the matrix
        */
        /**
         * A cell in the dictionary, storing both unpropagated and propagated score
         * @typedef {Object} dict_cell
         * @property {number} unpropagated
         * @property {number} propagated
        */
        /**
         * A result block.
         * @typedef {Object} wordblock
         * @property {number} label - The number corresponding to the type of the block (added, removed, etc)
         * @property {string} left - The left part
         * @property {string} right - The right part
        */
        /**
         * Options pertaining to the whole alignment algorithm.
         * @typedef {Object} alignmentOptions
         * @property {boolean} punct - True if punctuation should be ignored like whitespace is
         * @property {boolean} typecase - True if typecase differences should be ignored
         * @property {boolean} diacritics - True if differences in diacritics should be ignored
        */
        /**
         * Options pertaining to the score of two blocks.
         * @typedef {Object} scoreOptions - Leave out the parameters that shouldn't be calculated (or set to null)
         * @property {number} typecase - The score added to words that are the same after typecase normalisation
         * @property {number} diacritics - The score added to words that are the same after diacritics normalisation
         * @property {number} synonymy - The score added to synonyms
         * @property {number} archaism - The score added to archaisms
         * @property {number} gender - The score added to words that are the same after gender normalisation
         * @property {number} singular - The score added to words that are the same after normalisation to the singular form
         * @property {number} tense - The score added to words that are the same after grammatical tense normalisation
         * @property {number} root - The score added to words that share the same root (general grammatical normalisation)
         * @property {number} semantics - The score added to words in the same semantic field
         * @property {boolean} punctuation - True if punctuation is taken into account by the algorithm
         * @property {number[]} scale - The scale for the Levenshtein score function. 
        */
        /**
         * A cell on the path of the make_dict_boundaries function.
         * @typedef {object} multi_scale_cell
         * @property {number} x_coord
         * @property {number} y_coord
         * @property {boolean} top_right
         * @property {boolean} bottom_left
        */
        /**
         * The DELA_fr dictionary as JSON.
         * @typedef {Object} dela_dict - Contains dela_word objects with dictionary entry strings as keys.
        */
        /**
         * A word in a dela_dict.
         * @typedef {Object} dela_word
         * @property {!string[]} l
         * @property {!string[]} t
         * @property {?string[]} n - Grammatical number(s) and gender(s) if not a verb
         * @property {?string[]} c - Grammatical cation(s) if a verb
        */
        /**
         * An object representing a word and its diverse forms
         * @typedef {Object} wordobj
         * @property {string} initial - The initial form as is in the input
         * @property {string} lowercase
         * @property {string} NFD
         * @property {string} NFKD
         * @property {string} diacritics - NFKD + diacritics removed
         * @property {?string} in_dict - The form present in the dictionary
        */

        var left_panel = document.getElementById("left_panel");
        var right_panel = document.getElementById("right_panel");
        
        /**
         * Converts number coordinates into a string key for the dictionary, used to lower memory usage at the sacrifice of speed
         * @param {number} x
         * @param {number} y
         * @returns {coords}
        */
        function dkey(x,y) {
            return (x+","+y);
        }

        /**
         * Splits a text into an array of words (includes digits, diacritics and mathematical characters).
         * @param {string} text
         * @returns {string[]}
        */
        function string_to_words(text) {
            return text.split(/[\p{P}\p{Z}\p{C}]+/u).filter(block => block.length > 0); //the string is split according to the regular expression
        }
        
        /**
         * Splits a text into an array of punctuation strings (everything but letters, digits, diacritics and mathematical characters).
         * @param {string} text
         * @returns {string[]}
        */
        function string_to_punct(text) {
            return text.split(/[^\p{P}]+/u).filter(block => block.length > 0);
        }

        /**
         * Returns all the separators from a text (whitespaces etc).
         * @param {string} text
         * @returns {string[]}
        */
        function string_to_separators(text) {
            return text.split(/[^\p{Z}]+/u).filter(block => block.length > 0);
        }

        /**
         * Returns all the punctuation and separators from a text in a string array.
         * @param {string} text
         * @returns {string[]}
        */
        function string_to_punct_and_separators(text) {
            return text.split(/[^\p{P}\p{Z}\p{C}]+/u).filter(block => block.length > 0);
        }

        /**
         * Splits a text into words and punctuation.
         * @param {string} text
         * @returns {string[]}
        */
        function string_interlace(text) {
            return text.split(/[\p{Z}\p{C}]+/u).map(block => block.split((/([\p{P}]+)/gu))).flat().filter(block => block.length > 0);
        }

        function string_to_separators_with_rest(text) {
            let text1 = text.split(/([\p{Z}\p{C}]+)/gu);
            console.log(text1);
            let text2 = text1.map(block => block.split((/([\p{P}]+)/gu)));
            console.log(text2);
            let text3 = text2.flat().filter(block => block.length > 0 && !((/[]+/u).test(block)));
            console.log(text3);
            let text4 = text3.map(function(block) {
                if ((/[^\p{Z}\p{C}]/u).test(block)) return "";
                return block;
            });
            console.log(text4);
            return text4;
            /*return text.split(/([\p{Z}\p{C}]+)/u).map(block => block.split((/([\p{P}]+)/u))).flat().map(function(block) {
                if ((/[^\p{Z}\p{C}]/u).test(block)) return "";
                return block;
            });*/
        }

        /**
         * Converts an array of words into an array of wordobjs corresponding to the words of the text in order.
         * @param {string[]} text_array
         * @param {dela_dict} DELA
         * @returns {wordobj[]}
        */
        function text_array_to_wordobj_array(text_array, DELA) {
            /** @type {wordobj[]} */
            let wordobj_array = new Array();
            for (var word of text_array) {
                /** type {wordobj} */
                let added_wordobj = {initial:word};
                added_wordobj.lowercase = word.toLowerCase();
                added_wordobj.NFD = added_wordobj.lowercase.normalize("NFD");
                added_wordobj.NFKD = added_wordobj.lowercase.normalize("NFKD");
                added_wordobj.diacritics = added_wordobj.NFKD.replace(/[\p{Sk}\p{Lm}\p{M}]+/gu, '');
                let NFKC = word.normalize("NFKC");
                if (NFKC in DELA) added_wordobj.in_dict = NFKC;
                else if (NFKC.toLowerCase() in DELA) added_wordobj.in_dict = NFKC.toLowerCase();
                else added_wordobj.in_dict = null;
                wordobj_array.push(added_wordobj);
            }
            return wordobj_array;
        }

        /**
         * Calculates the Jaccard distance of two arrays.
         * @param {*[]} array1
         * @param {*[]} array2
         * @returns {number}
        */
        function jaccard_distance(array1, array2) {
            let m1 = new Minhash();
            let m2 = new Minhash();
            array1.map(function(w) {m1.update(w)});
            array2.map(function(w) {m2.update(w)});
            //console.log(1 - m1.jaccard(m2));
            return 1 - m1.jaccard(m2);
        }

        /**
         * Return a value between b and a for the similarity between two strings (considered words) using Levenshtein distance.
         * @param {number} a
         * @param {number} b
         * @param {string} word1
         * @param {string} word2
         * @returns {number}
        */
        function levenshtein_score(a, b, word1, word2) {
            if (word1.length + word2.length < 6) return 1;
            let word1_array = word1.split('');
            let word2_array = word2.split('');
            let matrix = new Array(word1_array.length+1);
            for (var i=0;i<word1_array.length+1;i++) {
                matrix[i] = new Array(word2_array.length+1);
                for (var j=0;j<word2_array.length+1;j++) { 
                    if (j==0) matrix[i][0] = i;
                    else if (i==0) matrix[0][j] = j;
                    else {
                        matrix[i][j] = (word1_array[i-1]==word2_array[j-1]) ? 0 : 2;
                        matrix[i][j] = Math.min(matrix[i][j-1]+1, matrix[i-1][j]+1, matrix[i][j]+matrix[i-1][j-1]);
                    }
                }
            }
            let result = matrix[word1_array.length][word2_array.length];
            // shortest path mathematically possible : |word1.length - word2.length|
            // longest path mathematically possible : word1.length + word2.length
            // if we want a levensthein difference index between 0 and 1, we could convert it to that scale
            console.log("path length for "+word1+" & "+word2+" : "+result);
            //let len_long = Math.max(word1_array.length, word2_array.length);
            let len_short = Math.min(word1_array.length, word2_array.length);
            // right now, we're using this as this yields the best results
            let return_value = (result > len_short) ? 1 : (a-b)*(result/len_short) + b;
            return return_value;
        }


        // TO TEST ON SAMPLE TEXTS, SCORES ARE AS FOLLOW FOR NOW
        /*
        equalities :
            NFD : 0
            lowercase : 0.02
            NFKD : 0.05
            diacritics : 0.1 
        in DELA :
            same lemma :
                (0.14 is calculated after verbs)
                both verbs :
                    not same number : 0.15
                    not same time : 0.16
                    not same person : 0.17
                    not same person & number : 0.18
                    not same time & number : 0.19
                    not same time & person : 0.2
                    nothing the same : 0.21
                share a type :
                    same number and gender : 0.14
                    not same gender : 0.22
                    not same number : 0.23
                    nothing the same : 0.24
                    no numgender in one of the two : 0.25
                just share a lemma : 0.26
            not the same lemma :
                are both CONJC : 0.27
                are both CONJS : 0.28
                are both DET : 0.29
                are both PRO : 0.3
                are both PREP :
                    if same subtype : 0.4
                    if different subtype : 0.45
                are both ADV : 0.5
                are both V with same numgender : 0.75
                are both AJD with same numgender : 0.8
        then return 1
        */

        /**
         * Returns a similarity score (between 0 and 1) for the similarity between two wordobjs using multiple comparisons (scores are additioned if multiple comparisons are needed).
         * @param {wordobj} word1
         * @param {wordobj} word2
         * @param {dela_dict} DELA
         * @param {scoreOptions} options
         * @returns {number}
        */
        function score(word1, word2, DELA) {
            if (word1.NFD == word2.NFD) return 0;
            if (word1.lowercase == word2.lowercase) return 0.02
            if (word1.NFKD == word2.NFKD) return 0.05;
            if (word1.diacritics == word2.diacritics) return 0.10;
            if ("in_dict" in word1 && "in_dict" in word2 && word1.in_dict != null && word2.in_dict != null) {
                //console.log("comparing "+word1.in_dict+" & "+word2.in_dict);
                //console.log(word1.l);
                //console.log(word2.l);
                //scores reserved for words that share a lemma : 0.14 to 0.26
                if (DELA[word1.in_dict].l.some(item => DELA[word2.in_dict].l.includes(item))) { //the words have the same lemma
                    //scores reserved for conjugation differences : 0.15 to 0.21
                    if ((DELA[word1.in_dict].t.some(item => item == "V")) && (DELA[word2.in_dict].t.some(item => item == "V"))) {
                        //the two words are conjugations of the same verb
                        let ret_value = 0.21; //score for difference in time, person/gender and number
                        for (var c1 of DELA[word1.in_dict].c) for (var c2 of DELA[word2.in_dict].c) {

                            //to make it faster, if you're sure of the values, automatically return if you find the lowest one
                            //you could also include the value of ret_value in the tests to skip the ones you don't need to test (and remove Math.min)
                            //this treats difference in gender as difference in grammatical person for now

                            if (c1.slice(0,2) == c2.slice(0,2)) {
                                ret_value = Math.min(ret_value, 0.15); //difference in number but not in person or time
                                continue;
                            }
                            if (c1.slice(1) == c2.slice(1)) {
                                ret_value = Math.min(ret_value, 0.16); //difference in time but not in number or person
                                continue;
                            } 
                            if (c1.slice(0,1) == c2.slice(0,1)) {
                                if (c1.slice(2) == c2.slice(2)) ret_value = Math.min(ret_value, 0.17); //difference in person but not in number or time
                                else ret_value = Math.min(ret_value, 0.18); //difference in person and number but not in time
                                continue;
                            }
                            if (c1.slice(1,2) == c2.slice(1,2)) {
                                ret_value = Math.min(ret_value, 0.19); //difference in time and number
                                continue;
                            }
                            if (c1.slice(2) == c2.slice(2)) ret_value = Math.min(ret_value, 0.2); //difference in time and person
                        }
                        return ret_value;
                    }
                    //scores reserved for gender and number differences when not verbs : 0.14 & 0.22 to 0.25
                    if (DELA[word1.in_dict].t.some(item => DELA[word1.in_dict].t.includes(item))) {
                        if ("n" in DELA[word1.in_dict] && "n" in DELA[word2.in_dict]) {
                            let ret_value = 0.24; //score for difference in gender and number
                            for (var n1 of DELA[word1.in_dict].n) for (var n2 of DELA[word2.in_dict].n) {
                                if (n1 == n2) return 0.14; //this means one word is a contraction of the other
                                if (n1.slice(0,1) == n2.slice(0,1)) {
                                    ret_value = 0.22; //difference in gender only
                                    continue;
                                }
                                if (n1.slice(1) == n2.slice(1)) ret_value = 0.23; //difference in number only
                            }
                            return ret_value;
                        }
                        //same lemma, not verbs, but no numgender associated
                        return 0.25;
                    }
                    //both words aren't verbs, although they share a lemma
                    return 0.26;
                }
                
                //our words don't share a lemma, scores from 0.27 to 1

                //scores reserved for "CONJC" : 0.27
                if ((DELA[word1.in_dict].t.some(item => item == "CONJC")) && (DELA[word2.in_dict].t.some(item => item == "CONJC"))) {
                    return 0.27;
                }
                //scores reserved for "CONJS" : 0.28
                if ((DELA[word1.in_dict].t.some(item => item == "CONJS")) && (DELA[word2.in_dict].t.some(item => item == "CONJS"))) {
                    return 0.28;
                }
                //scores reserved for "DET" : 0.29
                if ((DELA[word1.in_dict].t.some(item => item == "DET")) && (DELA[word2.in_dict].t.some(item => item == "DET"))) {
                    return 0.29;
                }
                //scores reserved for "PRO" : 0.3
                if ((DELA[word1.in_dict].t.some(item => item == "PRO")) && (DELA[word2.in_dict].t.some(item => item == "PRO"))) {
                    return 0.3;
                }
                //scores reserved for "PREP" (all types) : 0.4 & 0.45
                if ((DELA[word1.in_dict].t.some(item => (/PREP/).test(item))) && (DELA[word2.in_dict].t.some(item => (/PREP/).test(item)))) {
                    for (var type1 of DELA[word1.in_dict].t) for (var type2 of DELA[word2.in_dict].t) {
                        if ((/PREP/).test(type1) && (/PREP/).test(type2) && type1 == type2) return 0.4
                    }
                    // if both PREP but not the same type, higher value
                    return 0.45;
                }
                //scores reserved for "ADV" : 0.5
                if ((DELA[word1.in_dict].t.some(item => item == "ADV")) && (DELA[word2.in_dict].t.some(item => item == "ADV"))) {
                    return 0.5;
                }
                //scores reserved for conjugation similarities between dissimilar verbs : 0.65, 0.7, 0.75, 0.8, 0.85 & 0.9
                // ONLY TAKING INTO ACCOUNT WORDS THAT SHARE A CONJUGATION FOR NOW (0.75)
                if ((DELA[word1.in_dict].t.some(item => item == "V")) && (DELA[word2.in_dict].t.some(item => item == "V"))) { //the two words are verbs
                    //let ret_value = 0.9; //score for difference in time, person/gender and number
                    for (var c1 of DELA[word1.in_dict].c) for (var c2 of DELA[word2.in_dict].c) {
                        if (c1 == c2) return 0.75
                        /*if (c1.slice(0,2) == c2.slice(0,2)) {
                            ret_value = Math.min(ret_value, 0.65); //difference in number but not in person or time
                            continue;
                        }
                        if (c1.slice(1) == c2.slice(1)) {
                            ret_value = Math.min(ret_value, 0.7); //difference in time but not in number or person
                            continue;
                        } 
                        if (c1.slice(0,1) == c2.slice(0,1)) {
                            if (c1.slice(2) == c2.slice(2)) ret_value = Math.min(ret_value, 0.17); //difference in person but not in number or time
                            else ret_value = Math.min(ret_value, 0.75); //difference in person and number but not in time
                            continue;
                        }
                        if (c1.slice(1,2) == c2.slice(1,2)) {
                            ret_value = Math.min(ret_value, 0.8); //difference in time and number
                            continue;
                        }
                        if (c1.slice(2) == c2.slice(2)) ret_value = Math.min(ret_value, 0.85);*/ //difference in time and person
                    }
                    //return ret_value;
                }
                //scores reserved for number and gender similarities between different adjectives : 0.71, 0.76, 0.81, 0.86, 0.91
                // ONLY TAKING INTO ACCOUNT ADJECTIVES THAT SHARE THE SAME NUMGENDER FOR NOW (0.8)
                if ((DELA[word1.in_dict].t.some(item => item == "ADJ")) && (DELA[word2.in_dict].t.some(item => item == "ADJ"))) {
                    if ("n" in DELA[word1.in_dict] && "n" in DELA[word2.in_dict]) {
                        //let ret_value = 0.86; //score for difference in gender and number
                        for (var n1 of DELA[word1.in_dict].n) for (var n2 of DELA[word2.in_dict].n) {
                            if (n1 == n2) return 0.8;
                            /*if (n1.slice(0,1) == n2.slice(0,1)) {
                                ret_value = 0.76; //difference in gender only
                                continue;
                            }
                            if (n1.slice(1) == n2.slice(1)) ret_value = 0.81; //difference in number only*/
                        }
                        return ret_value;
                    }
                    //return 0.91;
                }
                //after filtration of the DELA, only "N" and "NPropre" subsist with "NPropre" always having "Hum"
                //scores reserved for number, gender and category similarities between different nouns ("N" xor "NPropre"): 0.67, 0.72, 0.77, 0.82, 0.87, 0.92, 0.97
                // NOT TAKING NOUNS INTO ACCOUNT FOR NOW
            }
            //if (("scale" in options) && (options.scale!=null)) return levenshtein_score(options.scale[1], options.scale[0], word1.NFD, word2.NFD);
            return 1;
        }

        /**
         * Returns a similarity score (between 0 and 1) for the similarity between two strings (considered words) using multiple comparisons (scores are additioned if multiple comparisons are needed).
         * @param {string} word1
         * @param {string} word2
         * @param {scoreOptions} options
         * @returns {number}
        */
        function alt_score(word1, word2, options) {
            if (options.punctuation) {
                if ((/[\p{P}]+/u).test(word1)) {
                    if ((/[\p{P}]+/u).test(word2)) {
                        if (word1==word2) return 0.85; //the same punctuation string
                        return 0.95; //two different punctuation strings
                    }
                    return 1; //one punctuation string and one word
                }
                if ((/[\p{P}]+/u).test(word2)) return 1; //idem
            }
            if (word1 == word2) return 0;
            if ((("typecase" in options) && (options.typecase != null)) && (word1.toLowerCase() == word2.toLowerCase())) return options.typecase;
            if (("diacritics" in options) && (options.diacritics != null)) {
                let diacritics_regex = /[\p{Sk}\p{Lm}\p{M}]+/gu;
                if (word1.normalize("NFD").replace(diacritics_regex,'') == word2.normalize("NFD").replace(diacritics_regex,'')) return options.diacritics;
                if ((("typecase" in options) && (options.typecase != null)) && (word1.toLowerCase().normalize("NFD").replace(diacritics_regex,'') == word2.toLowerCase().normalize("NFD").replace(diacritics_regex,''))) return options.typecase + options.diacritics;
                //normalisation NKFD normalise également les ligatures et formes anciennes de lettres (s long par ex.), à considérer
            }
            if (("scale" in options) && (options.scale!=null)) return levenshtein_score(options.scale[1], options.scale[0], word1.toLowerCase(), word2.toLowerCase());
            return 1;
        }

        /**
         * A grid corresponding to a Levenshtein distance matrix, both unpropagated and propagated, with the shortest path.
         * @typedef {Object} grid_display
         * @property {multi_scale_cell} path - An array of size 2 arrays representing coordinates : the shortest path from bottom right to top left.
         * @property {matrix} unpropagated
         * @property {matrix} propagated
        */
        /**
         * Fills and displays the "grid_popup" table with a path in a Levenshtein distance matrix.
         * @param {grid_display} grid_display
        */
        function show_path(grid_display) {
            let grid_popup = document.getElementById("grid_popup"); //the table div to be filled
            for (var y = 0; y < grid_display.unpropagated.length - 1; y++) {
                let new_row = document.createElement("tr"); //we create a row
                for (var x = 0; x < grid_display.unpropagated[0].length - 1; x++) {
                    let new_cell = document.createElement("td"); //we create a cell
                    new_cell.textContent = grid_display.unpropagated[y+1][x+1]; //we fill it with the corresponding score
                    new_cell.id = "x"+x+"y"+y; //we give it it's id (coordinates)
                    new_row.appendChild(new_cell); //we put the cell in the row
                }
                grid_popup.appendChild(new_row); //we put the row in the table
            }
            for (var coords of grid_display.path) { //we go through the path
                let target_cell = document.getElementById("x"+String(coords.x_coord)+"y"+String(coords.y_coord)); //the current cell in the path
                if (target_cell == null) console.log("cell null in x,y : "+coords.x_coord+","+coords.y_coord);
                target_cell.classList.add("path_cell"); //we give it the "path_cell" class to highlight it
            }
            grid_popup.style.display = "block"; //we show the table
            document.getElementById("popup_closer_button").style.display = "block"; //we show the closer button
        }
        
        /**
         * Hides the "grid_popup" table and its closer button.
        */
        function hide_path() {
            document.getElementById("grid_popup").style.display = "none";
            document.getElementById("popup_closer_button").style.display = "none";
        }

        /**
         * Divides the matrix in blocks and sets their boundaries as min and max for every line of the dict.
         * @param {string[]} text_array1 - The full word array of text 1
         * @param {string[]} text_array2 - The full word array of text 2
         * @param {dict} dict - The dict to be modified
         * @param {number} min_block_size - The size of the blocks
         * @param {number} max_matrix_size - The max size of the matrix (in number of cells)
        */
        function make_dict_boundaries(text_array1, text_array2, dict, min_block_size, max_matrix_size) {
            let div_amount_x = Math.floor(text_array2.length / min_block_size);
            let div_amount_y = Math.floor(text_array1.length / min_block_size);
            if (div_amount_x * div_amount_y > max_matrix_size) { //if the matrix is too big, we make the blocks bigger to avoid  too many minhash calculations
                //maybe we should increase it according to the square/cube root of the difference between the matrix size and the wanted matrix size, few minhashes on big sets isn't optimal either
                div_amount_x = Math.floor(Math.sqrt(max_matrix_size));
                div_amount_y = Math.floor(Math.sqrt(max_matrix_size));
            }
            if (div_amount_x > 2 && div_amount_y > 2) { //if it's interesting to divide the texts
                /** @type {grid_display} */
                let grid_display = {};
                let lvl2array1 = new Array(div_amount_y); //the arrays of text "blocks"
                let lvl2array2 = new Array(div_amount_x);
                let block_size_1 = text_array1.length / div_amount_y;
                let block_size_2 = text_array2.length / div_amount_x;
                for (var j = 0; j < div_amount_x; j++) lvl2array2[j] = text_array2.slice(Math.floor(j * block_size_2), Math.floor((j+1) * block_size_2)); //homogeneously dividing the texts into the arrays
                for (var j = 0; j < div_amount_y; j++) lvl2array1[j] = text_array1.slice(Math.floor(j * block_size_1), Math.floor((j+1) * block_size_1));
                /** @type {matrix} */
                let matrix = new Array(div_amount_y+1);
                grid_display.unpropagated = new Array(div_amount_y+1);
                grid_display.propagated = new Array(div_amount_y+1);
                for (var i = 0; i < div_amount_y + 1; i++) {
                    matrix[i] = new Array(div_amount_x + 1);
                    grid_display.unpropagated[i] = new Array(div_amount_x + 1);
                    grid_display.propagated[i] = new Array(div_amount_x + 1);
                    matrix[i][0] = i;
                    grid_display.unpropagated[i][0] = i; //only on the dev branch, to view the path in the multi-scale matrix
                    grid_display.propagated[i][0] = i;
                }
                for (var i = 1; i < div_amount_x + 1; i++) {
                    matrix[0][i] = i;
                    grid_display.unpropagated[0][i] = i;
                    grid_display.propagated[0][i] = i;
                }
                for (var i = 1; i < div_amount_y + 1; i++) for (var j = 1; j < div_amount_x + 1; j++) {
                    //calculation of jaccard distance / minhash
                    matrix[i][j] = ((i != j) && (matrix[j] != null) && (matrix[j][i] != null)) ? matrix[j][i] : jaccard_distance(lvl2array1[i-1], lvl2array2[j-1]);
                    grid_display.unpropagated[i][j] = matrix[i][j];
                    //propagation
                    matrix[i][j] = Math.min(matrix[i-1][j] + 1, matrix[i][j-1] + 1, matrix[i-1][j-1] + matrix[i][j]);
                    grid_display.propagated[i][j] = matrix[i][j];
                }
                /**@type {multi_scale_cell[]}*/
                let path = new Array();
                let x = div_amount_x;
                let y = div_amount_y;
                while (x > 0 && y > 0) {
                    if (x == 1) { //on the left border
                        if (y == 1) { //top-left cell
                            path.push({x_coord: x, y_coord: y-1, bottom_left: true});
                            path.push({x_coord: x-1, y_coord: y, top_right: true});
                        }
                        path.push({x_coord: x-1, y_coord: y-1});
                        y--;
                    }
                    else if (y == 1) { //on the top borer
                        path.push({x_coord: x-1, y_coord: y-1});
                        x--;
                    }
                    else {
                        path.push({x_coord: x-1, y_coord: y-1});
                        let left_value = matrix[y][x-1];
                        let top_value = matrix[y-1][x];
                        let diagonal_value = matrix[y-1][x-1];   
                        if (diagonal_value <= top_value) {
                            if (diagonal_value <= left_value) {
                                if (x != div_amount_x && y != div_amount_y) {
                                    //this prevents bottlenecking, it's a very uncomplicated solution that could be improved
                                    //one solution : create an auxilliar function to only put the lower/upper triangular matrix of the inside of a cell in the dict
                                    //other solution : prevent the path from going diagonally (only up and left), 1/3 faster but could also lead to bottlenecking
                                    path.push({x_coord: x, y_coord: y-1, bottom_left: true});
                                    path.push({x_coord: x-1, y_coord: y, top_right: true});
                                }
                                x--;
                                y--;
                            }
                            else x--;
                        }
                        else if (left_value <= top_value) x--;
                        else y--;
                    }
                }
                grid_display.path = [...path];
                show_path(grid_display);
                let min_max_per_block = new Array(lvl2array2.length); //array of minimal and maximal absolute x coordinate (text 2) per cell, uses cell coordinates as index
                min_max_per_block[0] = [0, lvl2array2[0].length - 1];
                for (var i = 1; i < lvl2array2.length; i++) min_max_per_block[i] = [min_max_per_block[i-1][1] + 1, min_max_per_block[i-1][1] + lvl2array2[i].length];
                let absolute_y_per_block = new Array(lvl2array1.length); //array of minimal and maximal absolute y coordinate (text 2) per cell, uses cell coordinates as index
                absolute_y_per_block[0] = [0, lvl2array1[0].length - 1];
                for (var i = 1; i < lvl2array1.length; i++) absolute_y_per_block[i] = [absolute_y_per_block[i-1][1] + 1, absolute_y_per_block[i-1][1] + lvl2array1[i].length];
                for (var coords of path) for (var i = absolute_y_per_block[coords.y_coord][0]; i <= absolute_y_per_block[coords.y_coord][1]; i++) {
                    dict.min_max[i].min = Math.min(dict.min_max[i].min, min_max_per_block[coords.x_coord][0]);
                    dict.min_max[i].max = Math.max(dict.min_max[i].max, min_max_per_block[coords.x_coord][1]);
                }
            }
        }

        /**
         * Calculates the Levenshtein distance matrix in a dict.
         * @param {wordobj[]} text_array1 - The full wordobj array of text 1 (y axis)
         * @param {wordobj[]} text_array2 - The full wordobj array of text 2 (x axis)
         * @param {dict} dict - The dict needs to have its min_max array already filled
         * @param {alignmentOptions} alignment_options
         * @param {dela_dict} DELA
        */
        function calculate_and_propagate(wordobj_array_1, wordobj_array_2, dict, alignment_options, DELA) {
            for (var y=0;y<dict.min_max.length;y++) { //for every line of the matrix
                //console.log("check min_max : "+dict.min_max[y].min+" - "+dict.min_max[y].max);
                if (dict.min_max[y].min = Infinity) dict.min_max[y] = {min: 0, max: wordobj_array_2.length - 1};
                for (var x = dict.min_max[y].min ; x <= dict.min_max[y].max ; x++) { //only in the existing cells
                    //console.log("cell "+y+" "+x)
                    //min(cost on the left + 1, cost on the right + 1, cost on the diagonal + 2 * current cost)
                    dict[dkey(x, y)] = {unpropagated: score(wordobj_array_1[y], wordobj_array_2[x], DELA)};
                    let left = (x == 0) ? y + 2 : (x == dict.min_max[y].min) ?  Infinity : dict[dkey(x-1, y)].propagated + 1;
                    let top  = (y == 0) ? x + 2 : (x > dict.min_max[y-1].max) ? Infinity : dict[dkey(x, y-1)].propagated + 1;
                    let diagonal = (y == 0 && x == 0) ? 0 : (y == 0) ? x + 1 : (x == 0) ? y + 1 : (x - 1 > dict.min_max[y-1].max || x - 1 < dict.min_max[y-1].min) ? Infinity : dict[dkey(x-1, y-1)].propagated + 2 * (dict[dkey(x, y)].unpropagated);
                    dict[dkey(x, y)].propagated = Math.min(left,top,diagonal);
                }
            }
        }

        /**
         * Creates a dictionary to store a Levensthein distance matrix.
         * @param {string[]} text_array1 - Array of words of text 1 (y axis)
         * @param {string[]} text_array2 - Array of words of text 2 (x axis)
         * @param {wordobj[]} wordobj_array_1 - The full wordobj array of text 1 (y axis)
         * @param {wordobj[]} wordobj_array_2 - The full wordobj array of text 2 (x axis)
         * @param {?number} start_time - Start time of algorithm, set to null if no time should be displayed in console
         * @param {alignmentOptions} alignment_options
         * @param {dela_dict} DELA
         * @returns {dict}
        */
        function create_dict (text_array1, text_array2, wordobj_array_1, wordobj_array_2, start_time, alignment_options, DELA) {
            if (start_time!=null) var dict_time = Date.now();
            /** @type {dict} */
            var cost_dict = {min_max: new Array(text_array1.length)};
            for (var i=0;i<cost_dict.min_max.length;i++) { //pre-filling the min_max array for an easier later filling
                cost_dict.min_max[i] = {};
                cost_dict.min_max[i].min = Infinity;
                cost_dict.min_max[i].max = -Infinity;
            }
            make_dict_boundaries(text_array1, text_array2, cost_dict, (alignment_options.punct) ? 100 : 200, 160000);
            if (start_time!=null) {
                console.log("time taken to make the dict boundaries : "+(Date.now()-dict_time)+" ms, total time : "+(Date.now()-start_time)+" ms");
                dict_time = Date.now();
            }
            calculate_and_propagate(wordobj_array_1, wordobj_array_2, cost_dict, alignment_options, DELA);
            //cost_dict = propagate(cost_dict);
            if (start_time!=null) {
                console.log("time taken to calculate & propagate : "+(Date.now()-dict_time)+" ms, total time : "+(Date.now()-start_time)+" ms");
            }
            //we now have the full propagated cost dictionary, we can start the pathfinding
            return cost_dict;
        }

        /**
         * The non-recursive pathmaking function, returns an array of result blocks corresponding to the best path available.
         * @param {!dict} dict - The fully propagated dictionary used
         * @param {!string[]} text_array1 - The full word array for text 1 (on the y axis)
         * @param {!string[]} text_array2 - The full word array for text 2 (on the x axis)
         * @param {alignmentOptions} alignment_options
         * @returns {wordblock[]}
        */
        function make_out_path(dict,text_array1,text_array2, alignment_options) {   
            let result_array = new Array();
            let x = text_array2.length-1; //we start in the bottom right corner
            let y = text_array1.length-1;
            while (x>=-1 && y>=-1) { // this is only to avoid errors, the while should end on 'break;' instructions if nothing wrong happens
                //console.log("x,y : "+x+","+y);
                if (x<=-1) { //on the left-most side of the dict
                    if (y<=-1) break; //on the top left corner
                    for (var i=y;i>=0;i--) {
                        result_array.push({label:2, left:text_array1[i], right:""});
                        //console.log("up (on the left side)");
                    }
                    break;
                }
                if (y<=-1) { //on the top of the dict
                    for (var i=x;i>=0;i--) {
                        result_array.push({label:3, left:"", right:text_array2[i]});
                        //console.log("left (on the top side)");
                    }
                    break;
                }
                let diagonal_value = (dkey(x-1,y-1) in dict) ? dict[dkey(x-1,y-1)].propagated : null;
                let left_value = (dkey(x-1,y) in dict) ? dict[dkey(x-1,y)].propagated : null;
                let top_value = (dkey(x,y-1) in dict) ?  dict[dkey(x,y-1)].propagated : null;

                // !!!! the following block (border) should be optimised using min_max

                if (left_value==null && top_value==null) {
                    result_array.push({label: dict[dkey(x, y)].unpropagated, left: text_array1[y], right:text_array2[x]});
                    x--;
                    y--;
                    //console.log("diag (in 0,0 or no left nor top square)");
                    continue;
                }
                if (left_value==null) { //we have to go up
                    result_array.push({label:2, left:text_array1[y],right:""});
                    //console.log("up (no left square)");
                    y--;
                    continue;
                }
                else if (top_value==null) { //we have to go left
                    result_array.push({label:3, left:"", right:text_array2[x]});
                    //console.log("left (no top square)");
                    x--;
                    continue;
                }
                // now we know we're not on a border
                if (text_array1[y]==null) console.log("error in y="+y);
                if (text_array2[x]==null) console.log("error in x="+x);
                //console.log("not on border, word1 : "+text_array1[y]+", word2 : "+text_array2[x]);
                if (diagonal_value <= left_value && diagonal_value <= top_value) {
                    let new_label = dict[dkey(x, y)].unpropagated //non restricted label for further comparison
                    if (new_label<1) {
                        result_array.push({label:new_label, left: text_array1[y], right:text_array2[x]});
                        //console.log("diag (diag <= top & diag <= left & non-strict score < 1)");
                        x--;
                        y--;
                    }
                    else if (left_value < top_value) {
                        result_array.push({label:3, left:"", right:text_array2[x]});
                        //console.log("left (non-strict score >=1 and left < top)");
                        x--;
                    }
                    else {
                        result_array.push({label:2, left:text_array1[y],right:""});
                        //console.log("up (non-strict score >=1 and top <= left)");
                        y--;
                    }
                }
                else if (left_value < top_value) {
                    result_array.push({label:3, left:"", right:text_array2[x]});
                    //console.log("left (score >=1 and left < top)");
                    x--;
                }
                else {
                    result_array.push({label:2, left:text_array1[y],right:""});
                    //console.log("up (score >=1 and top <= left)");
                    y--;
                }
            }
            return result_array;
        }

        /**
         * Fuses blocks of similar nature and adds punctuation.
         * @param {wordblock[]} text_array - The non-fused path
         * @param {string} text1 - The full first text (on the y axis)
         * @param {string} text2 - The full second text (on the x axis)
         * @param {alignmentOptions} alignment_options
         * @returns {wordblock[]}
        */
        function alt_bring_text_back(text_array, text1, text2, alignment_options) {
            /** @type {wordblock[]} */
            let result_array = new Array(0);
            var pt_1 = 0;
            var pt_2 = 0;
            if (alignment_options.punct) { //if punctuation isn't taken into account by the algorithm
                let separators_array_1 = string_to_punct_and_separators(text1); //the first text's punctuation
                let separators_array_2 = string_to_punct_and_separators(text2); //same for text 2
                //console.log(separators_array_1);
                if ((/[\p{P}]/u).test(text1.slice(0,1))) {
                    result_array.push({label: 4, left: separators_array_1[pt_1], right: ""});
                    pt_1++;
                }
                if ((/[\p{P}]/u).test(text2.slice(0,1))) {
                    result_array.push({label: 4, left: "", right: separators_array_2[pt_2]});
                    pt_2++;
                }
                for (var block of text_array) {
                    result_array.push(block);
                    if ((block.label != 3) && (pt_1 < separators_array_1.length)) {
                        let new_block = {label:4, left: separators_array_1[pt_1], right: ""};
                        //console.log(new_block);
                        result_array.push(new_block);
                        pt_1++;
                    }
                    if ((block.label != 2) && (pt_2 < separators_array_2.length)) {
                        let new_block = {label:4, left: "", right: separators_array_2[pt_2]};
                        //console.log(new_block);
                        result_array.push(new_block);
                        pt_2++;
                    }
                }
            }
            else {
                let separators_array_1 = string_to_separators_with_rest(text1);
                let separators_array_2 = string_to_separators_with_rest(text2);
                //console.log(separators_array_1);
                if (separators_array_1[pt_1].length != 0) {
                    result_array.push({label: 4, left: separators_array_1[pt_1], right: ""});
                    pt_1++;
                }
                if (separators_array_2[pt_2].length != 0) {
                    result_array.push({label: 4, left: "", right: separators_array_2[pt_2]});
                    pt_2++;
                }
                for (var block of text_array) {
                    result_array.push(block);
                    pt_1++;
                    pt_2++;
                    if ((block.label != 3) && (pt_1 < separators_array_1.length) && (separators_array_1[pt_1].length != 0)) {
                        let new_block = {label:4, left: separators_array_1[pt_1], right: ""};
                        //console.log(new_block);
                        result_array.push(new_block);
                        pt_1++;
                    }
                    if ((block.label != 2) && (pt_2 < separators_array_2.length) && (separators_array_2[pt_2].length != 0)) {
                        let new_block = {label:4, left: "", right: separators_array_2[pt_2]};
                        //console.log(new_block);
                        result_array.push(new_block);
                        pt_2++;
                    }
                }
            }
            return result_array;
        }

        /**
         * Converts a number to a class list string.
         * @param {number} typeint - 0 if unchanged, 2 if removed, 3 if added, 4 if punctuation, 1 if parallel but non corresponding, between 0 and 1 if changed
         * @returns {string}
        */
        function int_to_type(typeint) {
            if (typeint==0) return "unchanged";
            if (typeint<1) return "changed"
            if (typeint==1) return "non_corresponding";
            if (typeint==2) return "removed";
            if (typeint==3) return "added";
            if (typeint==4) return "separators";
            /*if (typeint==0.1) return "changed typecase";
            if (typeint==0.2) return "changed diacritics";
            if (typeint==0.3) return "changed typecase diacritics";
            if (typeint==0.85) return "unchanged punct";
            if (typeint==0.95) return "changed punct";*/
            return "changed";
        }

        /**
         * Function tied to a span, clicking on this span scrolls it and its 'parallel' span in the middle of the display panels.
         * @param {string} block_id - The id of the span, with format [1-9][0-9]*
        */
        function scroll_to_id(block_id) {
            let offsetHeight = document.querySelector("#left_panel").clientHeight / 2;
            document.querySelector("#left_panel").scrollTop = document.querySelector("#l_"+block_id).offsetTop - offsetHeight;
            document.querySelector("#right_panel").scrollTop = document.querySelector("#r_"+block_id).offsetTop - offsetHeight;
        }

        /**
         * Creates spans in the result display panels.
         * @param {wordblock[]} text_array - The path
        */
        function make_spans(text_array) {
            let span_id = 0;
            for (var block of text_array) {
                span_id++;
                let classes = int_to_type(block.label).split(" "); //all the classes added
                if (block.label!=3) { //create a span on the left
                    let new_span_left = document.createElement("span");
                    new_span_left.classList.add("text_part",classes);
                    new_span_left.id = "l_"+span_id; //the span id used for synchronised scrolling
                    new_span_left.textContent = block.left;
                    //console.log(block.left+" - "+new_span_left.textContent);
                    document.getElementById("left_panel").appendChild(new_span_left);
                }
                if (block.label!=2) { //create a span on the right
                    let new_span_right = document.createElement("span");
                    new_span_right.classList.add("text_part",classes);
                    new_span_right.id = "r_"+span_id; //the span id used for synchronised scrolling
                    new_span_right.textContent = block.right;
                    document.getElementById("right_panel").appendChild(new_span_right);
                }
            }
        }

        /**
         * Changes the page setup to display the loading screen.
        */
        function change_to_loading_screen() {
            document.querySelectorAll("textarea").forEach(element => {
                element.style.display = "none";
            });
            document.querySelector("#align_button").style.display = "none";
            document.querySelectorAll(".checkbox_container").forEach(element => {
                element.style.display = "none"
            });
            /*let loader = document.querySelector("#loader")
            //loader.style.display = "block";
            var op = 0.1;  // initial opacity
            var timer = setInterval(function () {
                if (op >= 1){
                    clearInterval(timer);
                }
                loader.style.opacity = op;
                loader.style.filter = 'alpha(opacity=' + op * 100 + ")";
                op += op * 0.04;
            }, 10);
            delete op;
            delete timer;*/
        }

        /**
         * Changes the page setup to display the results and adds event listeners to the text_area spans.
        */
        function change_to_result_screen() {
            /*let loader = document.querySelector("#loader")
            var op = 1;  // initial opacity
            var timer = setInterval(function () {
                if (op <=0.1) {
                    clearInterval(timer);
                }
                loader.style.opacity = op;
                loader.style.filter = 'alpha(opacity=' + op * 100 + ")";
                op -= op * 0.06;
            }, 10);
            delete op;
            delete timer;
            loader.style.display = "none";*/
            document.querySelectorAll(".panel").forEach(element => {
                element.style.display = "block";
            });
            document.querySelectorAll(".unchanged:not(punct), .changed:not(punct)").forEach(element => {
                var id = element.id.split('_')[1];
                element.addEventListener("click", function() {scroll_to_id(id);}); //on click, scrolls the span and its parallel span to the middle
                element.addEventListener("mouseenter", function() { //on hover, underlines the span and its parallel span
                    document.getElementById("l_"+id).style.textDecoration = "solid underline";
                    document.getElementById("r_"+id).style.textDecoration = "solid underline";
                });
                element.addEventListener("mouseleave", function() {
                    document.getElementById("l_"+id).style.textDecoration = "none";
                    document.getElementById("r_"+id).style.textDecoration = "none";
                });
            });
            //document.querySelector("#reset_button").style.display = "block";
            //document.querySelector("#export_button").style.display = "block";
            
        }

        /**
         * Fetches the DELA JSON file and returns it.
         * @returns {dela_dict}
        */
        async function load_dela() {
            return fetch(new Request("https://maxb9f.github.io/COATL-LIGM/data/dela.txt.json", {
                method: 'GET'
            }))
            .then(response => response.json());
        }

        document.addEventListener("DOMContentLoaded", function(){
            console.log("DOM Content Loaded");
            //after the DOM has been loaded
            //we hide the grid display
            hide_path();
            //we add the click listener for the popup closer
            document.querySelector("#popup_closer_button").addEventListener("click",function() {
                hide_path();
            });
            /** @type {alignmentOptions} */
            var alignment_options = {
                typecase: false,
                diacritics: false,
                punct: true
            };
            document.querySelector("#punct_check").addEventListener("change", (event) => {
                if (event.currentTarget.checked) {
                    alignment_options.punct = true;
                    console.log("punct true");
                }
                else {
                    alignment_options.punct = false;
                    console.log("punct false");
                }
            });
            document.querySelector("#typecase_check").addEventListener("change", (event) => {
                if (event.currentTarget.checked) {
                    alignment_options.typecase = true;
                    console.log("typecase true");
                }
                else {
                    alignment_options.typecase = false;
                    console.log("typecase false");
                }
            });
            document.querySelector("#diacritics_check").addEventListener("change", (event) => {
                if (event.currentTarget.checked) {
                    alignment_options.diacritics = true;
                    console.log("diacritics true");
                }
                else {
                    alignment_options.diacritics = false;
                    console.log("diacritics false");
                }
            });
            //we hide the result panels
            document.querySelectorAll(".panel").forEach(element => {element.style.display = "none";});
            //we add the click listener for the align button
            document.querySelector("#align_button").addEventListener("click", async function(){ //on click
                //remove visibility of button and interaction with textareas

                let start = Date.now();
                /** @type {string} */
                var left_text = document.querySelector("#left_textarea").value.normalize("NFC"); //scans the left textarea
                /** @type {string} */
                var right_text = document.querySelector("#right_textarea").value.normalize("NFC"); //scans the right textarea
                var ta1 = (alignment_options.punct) ? string_to_words(left_text) : string_interlace(left_text); //split the left text into words
                console.log("length of left text : "+ta1.length+" blocks");
                var ta2 = (alignment_options.punct) ? string_to_words(right_text) : string_interlace(right_text);
                console.log("length of right text : "+ta2.length+" blocks");
                if (ta1.length==0 || ta2.length==0) {
                    return;
                }
                //need an await instruction here
                change_to_loading_screen();

                const DELA = await load_dela();
                console.log(Object.keys(DELA).length);


                let wa1 = text_array_to_wordobj_array(ta1, DELA);
                let wa2 = text_array_to_wordobj_array(ta2, DELA);
                console.log(wa1.length);
                var levenshtein_dict = create_dict(ta1, ta2, wa1, wa2, start, alignment_options, DELA);
                //now that we have the dict, we can do the pathmaking
                console.log("starting pathfinding");
                let path_time = Date.now();
                var path_ta = make_out_path(levenshtein_dict, ta1, ta2, alignment_options);
                console.log("time taken to make the path : " + (Date.now() - path_time) + " ms, total time : " + (Date.now() - start) + " ms");
                path_ta.reverse();
                //console.log(path_ta);
                //then bring_text_back to fuse the groups and add punctuation
                path_ta = alt_bring_text_back(path_ta, left_text, right_text, alignment_options);
                //then make divs to create the divs inside of the panels
                make_spans(path_ta);
                //then we have to change page setup
                change_to_result_screen();
                console.log("result shown, total time : " + (Date.now() - start) + " ms");
            });
        });
    </script>
</head>
<body>
    <header>
        <div id="logo_div">
            <a href="./index.html" id="logo_anchor">
                <img width="90" height="90" src="./logoIGM-300x298.png" alt="Laboratoire d'Informatique Gaspard-Monge" decoding="async">
            </a>
        </div>
        <div id="titlediv">
            <h1>COATL</h1>
        </div>
        <div id="links">
            <ul id="links_list">
                <li><a href="https://siteigm.univ-mlv.fr/" target="_blank">Site du LIGM</a></li>
                <li><a href="https://github.com/maxB9F/COATL-LIGM" target="_blank">Dépôt Github</a></li>
            </ul>
        </div>
    </header>
    <table id="grid_popup"></table>
    <button id="popup_closer_button">Close</button>
    <div class="box" id="outerbox">
        <div class="box" id="innerbox">
            <textarea autocomplete="off" minlength="1" spellcheck="false" id="left_textarea" placeholder="La première version du texte"></textarea>
            <textarea autocomplete="off" minlength="1" spellcheck="false" id="right_textarea" placeholder="La seconde version du texte"></textarea>
            <div class="panel" id="left_panel"></div>
            <div class="panel" id="right_panel"></div>
        </div>
        <div class="box" id="button_box">
            <div class="checkbox_container">
                <input type="checkbox" id="punct_check" checked>
                <label for="punct_check">Ignorer la ponctuation et les séparateurs</label>
            </div>
            <div class="checkbox_container">
                <input type="checkbox" id="typecase_check">
                <label for="typecase_check">Ignorer les différences de casse typographique</label>
            </div>
            <div class="checkbox_container">
                <input type="checkbox" id="diacritics_check">
                <label for="diacritics_check">Ignorer les différences de signes diacritiques</label>
            </div>
            <button id="align_button"  type="button">Align</button>
            <button id="reset_button"  type="button">Reset</button>
            <button id="export_button" type="button">Export</button>
        </div>
    </div>
    <!--<img width="150" height="149" src="./logoIGM-300x298.png" id="loader">-->
</body>
</html>