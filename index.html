<!doctype html>
<!--
    COATL - Alignment Tool for Litterary (or other) texts.
    Copyright (C) 2023 Maxime Kremer

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<html lang="fr">
<head>
    <meta charset="utf-8">
    <title>COATL</title>
    <style>
        body {
            margin: 0;
            height: 100%;
            overflow: hidden;
        }

        header {
            padding: 0 0.5em;
            height: 100px;
            background-color: #E0E0E0;
            display: flex;
            flex-flow: row wrap;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 0 10px 0 grey;
            overflow: hidden;
            margin-bottom: 1em;
        }

        #links {
            width: 286px;
            height: 90px;
            margin: 5px 0.5em;
        }

        #links_list {
            margin: 0;
            padding: 0;
            height: 90px;
            display: flex;
            flex-flow: column nowrap;
            align-items: center;
            justify-content: space-evenly;
        }

        #logo_div {
            margin: 5px 0.5em;
            width: 286px;
        }

        #logo_anchor {
            display:flex;
        }

        button {
            width: 90px;
            height: 30px;
            margin: 1em;
        }

        .checkbox_container {
            height: 30px;
            margin: 1em;
        }

        textarea, .panel {
            margin: 1em;
            margin-bottom: 0;
            min-width: 20em;
            min-height: 10em;
            max-height: 100vh;
            max-width: 100vw;
            padding: 1em;
            font-size: 16px;
            flex: 0 5 100%;
            align-self: stretch;
            border-radius: 3px;
        }

        textarea {
            resize: none;
        }

        .box {
            display:flex;
            align-items: center;
        }

        #outerbox {
            flex-flow: column nowrap;
            height: auto;
            width: 100%;
            position: absolute;
            left: 0;
            right: 0;
            bottom: 30px;
            top: 100px;
        }

        #innerbox {
            flex-flow: row nowrap;
            padding: 0 3em;
            min-height: 0;
            flex: 0 10 100%;
            align-self: stretch;
        }

        #button_box {
            flex-flow: row wrap;
            flex: 0 0 auto;
            align-self: stretch;
            justify-content: center;
        }

        .panel {
            overflow-y: auto;
            background-color: white;
            height: auto;
            width: auto;
            overflow-wrap: break-word;
        }

        .text_part {
            white-space: pre-wrap;
            color: rgb(40,40,40);
        }

        .changed {
            color: white;
            background-color: darkviolet;
        }

        .changed:hover, .unchanged:hover {
            text-decoration: solid underline;
        }

        .removed, #left_panel > .non_corresponding {
            color: white;
            background-color: red;
        }

        .added, #right_panel > .non_corresponding {
            color: white;
            background-color: blue;
        }

        #reset_button, #export_button {
            display: none;
        }
    </style>
    <script>
        /*The MIT License

        Copyright (c) 2010-2018 Douglas Duhaime http://douglasduhaime.com

        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:

        The above copyright notice and this permission notice shall be included in
        all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        THE SOFTWARE.*/
        'use strict';

        /**
        * Minhash class - generates minhash signatures for set
        **/
        var Minhash = function(config) {

        // prime is the smallest prime larger than the largest
        // possible hash value (max hash = 32 bit int)
        this.prime = 4294967311;
        this.maxHash = Math.pow(2, 32) - 1;

        // initialize the hash values as the maximum value
        this.inithashvalues = function() {
            for (var i=0; i<this.numPerm; i++) {
            this.hashvalues.push(this.maxHash);
            }
        }

        // initialize the permutation functions for a & b
        // don't reuse any integers when making the functions
        this.initPermutations = function() {
            var used = {};
            for (var i=0; i<2; i++) {
            var perms = [];
            for (var j=0; j<this.numPerm; j++) {
                var int = this.randInt();
                while (used[int]) int = this.randInt();
                perms.push(int);
                used[int] = true;
            }
            var key = ['permA', 'permB'][i];
            this[key] = perms;
            }
        }

        // the update function updates internal hashvalues given user data
        this.update = function(str) {
            for (var i=0; i<this.hashvalues.length; i++) {
            var a = this.permA[i];
            var b = this.permB[i];
            var hash = (a * this.hash(str) + b) % this.prime;
            if (hash < this.hashvalues[i]) {
                this.hashvalues[i] = hash;
            }
            }
        }

        // hash a string to a 32 bit unsigned int
        this.hash = function(str) {
            var hash = 0;
            if (str.length == 0) {
            return hash + this.maxHash;
            }
            for (var i = 0; i < str.length; i++) {
            var char = str.charCodeAt(i);
            hash = ((hash<<5)-hash)+char;
            hash = hash & hash; // convert to a 32bit integer
            }
            return hash + this.maxHash;
        }

        // estimate the jaccard similarity to another minhash
        this.jaccard = function(other) {
            if (this.hashvalues.length != other.hashvalues.length) {
            throw new Error('hashvalue counts differ');
            } else if (this.seed != other.seed) {
            throw new Error('seed values differ');
            }
            var shared = 0;
            for (var i=0; i<this.hashvalues.length; i++) {
            shared += this.hashvalues[i] == other.hashvalues[i];
            }
            return shared / this.hashvalues.length;
        }

        // return a random integer >= 0 and <= maxHash
        this.randInt = function() {
            var x = Math.sin(this.seed++) * this.maxHash;
            return Math.floor((x - Math.floor(x)) * this.maxHash);
        }

        // initialize the minhash
        var config = config || {};
        this.numPerm = config.numPerm || 128;
        this.seed = config.seed || 1;
        this.hashvalues = [];
        this.permA = [];
        this.permB = [];
        // share permutation functions across all minhashes
        this.inithashvalues();
        this.initPermutations();
        };

        if (typeof window !== 'undefined') window.Minhash = Minhash;

        if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = Minhash;
        }
        exports = Minhash;
        }
    </script>
    <script>
        /**
         * A min and a max corresponding to a row of the matrix, with the first and last cells to be filled.
         * @typedef {Object} min_max_cell
         * @property {number} max
         * @property {number} min
        */
        /**
         * A matrix of numbers
         * @typedef {Array.<number[]>} matrix
        */
        /**
         * Coordinates in a dict to avoid wasting memory, in the following format : "x,y".
         * @typedef {string} coords
        */
        /**
         * A dictionary corresponding to a full Levenshtein distance matrix (without first row and first column).
         * @typedef {Object} dict - Use a 'coords' type key to access the value stored at those coordinates
         * @property {min_max_cell[]} min_max - The first and last filled cell of every row in the matrix
        */
        /**
         * A result block.
         * @typedef {Object} wordblock
         * @property {number} label - The number corresponding to the type of the block (added, removed, etc)
         * @property {string} left - The left part
         * @property {string} right - The right part
        */
        /**
         * Options pertaining to the whole alignment algorithm.
         * @typedef {Object} alignmentOptions
         * @property {boolean} punct - True if punctuation and whitespace should be compared
         * @property {boolean} typecase - True if typecase differences should be considered
        */
        /**
         * Options pertaining to the score of two blocks.
         * @typedef {Object} scoreOptions - Leave out the parameters that shouldn't be calculated (or set to null)
         * @property {number} typecase - The score added to words that are the same after typecase normalisation
         * @property {number} diacritics - The score added to words that are the same after diacritics normalisation
         * @property {number[]} scale - The scale for the Levenshtein score function. 
        */
        /**
         * A cell on the path of the make_dict_boundaries function.
         * @typedef {object} multi_scale_cell
         * @property {number} x_coord
         * @property {number} y_coord
         * @property {boolean} top_right
         * @property {boolean} bottom_left
        */
        var left_panel = document.getElementById("left_panel");
        var right_panel = document.getElementById("right_panel");
        
        /**
         * Converts number coordinates into a string key for the dictionary, used to lower memory usage at the sacrifice of speed
         * @param {number} x
         * @param {number} y
         * @returns {coords}
        */
        function dkey(x, y) {
            return (x + "," + y);
        }

        /**
         * Splits a text into an array of words (includes digits, diacritics and mathematical characters).
         * @param {string} text
         * @returns {string[]}
        */
        function string_to_words(text) {
            return text.split(/[^\p{Script=Latin}]+/u).filter(block => block.length > 0);
        }
        
        /**
         * Splits a text into an array of punctuation strings (everything but letters, digits, diacritics and mathematical characters).
         * @param {string} text
         * @returns {string[]}
        */
        function string_to_punct(text) {
            return text.split(/[\p{Script=Latin}]+/u).filter(block => block.length > 0);
        }

        /**
         * Splits a text into words and punctuation.
         * @param {string} text
         * @returns {string[]}
        */
        function string_interlace(text) {
            return text.split(/([^\p{Script=Latin}]+)/u).filter(block => block.length > 0); 
        }

        /**
         * Calculates the Jaccard distance of two arrays.
         * @param {*[]} array1
         * @param {*[]} array2
         * @returns {number}
        */
        function jaccard_distance(array1, array2) {
            let m1 = new Minhash();
            let m2 = new Minhash();
            array1.map(function(w) {m1.update(w)});
            array2.map(function(w) {m2.update(w)});
            return 1 - m1.jaccard(m2);
        }

        /**
         * Return a value between b and a for the similarity between two strings (considered words) using Levenshtein distance.
         * @param {number} a
         * @param {number} b
         * @param {string} word1
         * @param {string} word2
         * @returns {number}
        */
        function levenshtein_score(a, b, word1, word2) {
            if (word1.length + word2.length < 6) return 1;
            let word1_array = word1.split('');
            let word2_array = word2.split('');
            let matrix = new Array(word1_array.length+1);
            for (var i = 0; i < word1_array.length + 1; i++) {
                matrix[i] = new Array(word2_array.length+1);
                for (var j = 0; j < word2_array.length + 1; j++) {
                    if (j==0) matrix[i][0] = i;
                    else if (i==0) matrix[0][j] = j;
                    else matrix[i][j] = Math.min(matrix[i][j-1] + 1, matrix[i-1][j] + 1, ((word1_array[i-1] == word2_array[j-1]) ? 0 : 2) + matrix[i-1][j-1]);
                } 
            }
            let result = matrix[word1_array.length][word2_array.length];
            let len_short = Math.min(word1_array.length, word2_array.length);
            let return_value = (result > len_short) ? 1 : (a - b) * (result / len_short) + b;
            return return_value;
        }

        /**
         * Returns a similarity score (between 0 and 1) for the similarity between two strings (considered words) using multiple comparisons (scores are additioned if multiple comparisons are needed).
         * @param {string} word1
         * @param {string} word2
         * @param {scoreOptions} options
         * @returns {number}
        */
        function score(word1, word2, options) {
            if (word1 == word2) return 0;
            if ((("typecase" in options) && (options.typecase != null)) && (word1.toLowerCase() == word2.toLowerCase())) return options.typecase;
            if (("diacritics" in options) && (options.diacritics != null)) {
                if (word1.normalize("NFD") == word2.normalize("NFD")) return options.diacritics;
                if ((("typecase" in options) && (options.typecase != null)) && (word1.toLowerCase().normalize("NFD") == word2.toLowerCase().normalize("NFD"))) return options.typecase + options.diacritics;
                //normalisation NKFD normalise également les ligatures et formes anciennes de lettres (s long par ex.), à considérer
            }
            if (("scale" in options) && (options.scale != null)) return levenshtein_score(options.scale[1], options.scale[0], word1.toLowerCase(), word2.toLowerCase());
            return 1;
        }

        /**
         * Divides the matrix in blocks and sets their boundaries as min and max for every line of the dict.
         * @param {string[]} text_array1 - The full word array of text 1
         * @param {string[]} text_array2 - The full word array of text 2
         * @param {dict} dict - The dict to be modified
         * @param {number} min_block_size - The size of the blocks
         * @param {number} max_matrix_size - The max size of the matrix (in number of cells)
        */
        function make_dict_boundaries(text_array1, text_array2, dict, min_block_size, max_matrix_size) {
            let div_amount_x = Math.floor(text_array2.length / min_block_size);
            let div_amount_y = Math.floor(text_array1.length / min_block_size);
            if (div_amount_x * div_amount_y > max_matrix_size) {
                div_amount_x = Math.floor(Math.sqrt(max_matrix_size));
                div_amount_y = Math.floor(Math.sqrt(max_matrix_size));
            }
            if (div_amount_x > 2 && div_amount_y > 2) {
                let lvl2array1 = new Array(div_amount_y);
                let lvl2array2 = new Array(div_amount_x);
                let block_size_1 = text_array1.length / div_amount_y;
                let block_size_2 = text_array2.length / div_amount_x;
                for (var j = 0; j < div_amount_x; j++) lvl2array2[j] = text_array2.slice(Math.floor(j * block_size_2), Math.floor((j+1) * block_size_2));
                for (var j = 0; j < div_amount_y; j++) lvl2array1[j] = text_array1.slice(Math.floor(j * block_size_1), Math.floor((j+1) * block_size_1));
                /** @type {matrix} */
                let matrix = new Array(div_amount_y+1);
                for (var i = 0; i < div_amount_y + 1; i++) {
                    matrix[i] = new Array(div_amount_x + 1);
                    matrix[i][0] = i;
                }
                for (var i = 1; i < div_amount_x + 1; i++) matrix[0][i] = i;
                for (var i = 1; i < div_amount_y + 1; i++) for (var j = 1; j < div_amount_x + 1; j++) {
                    matrix[i][j] = ((i != j) && (matrix[j] != null) && (matrix[j][i] != null)) ? matrix[j][i] : jaccard_distance(lvl2array1[i-1], lvl2array2[j-1]);
                    matrix[i][j] = Math.min(matrix[i-1][j] + 1, matrix[i][j-1] + 1, matrix[i-1][j-1] + matrix[i][j]);
                }
                /**@type {multi_scale_cell[]}*/
                let path = new Array();
                let x = div_amount_x;
                let y = div_amount_y;
                while (x > 0 && y > 0) {
                    if (x == 1) {
                        if (y == 1) {
                            path.push({x_coord: x, y_coord: y-1, bottom_left: true});
                            path.push({x_coord: x-1, y_coord: y, top_right: true});
                        }
                        path.push({x_coord: x-1, y_coord: y-1});
                        y--;
                    }
                    else if (y == 1) {
                        path.push({x_coord: x-1, y_coord: y-1});
                        x--;
                    }
                    else {
                        path.push({x_coord: x-1, y_coord: y-1});
                        let left_value = matrix[y][x-1];
                        let top_value = matrix[y-1][x];
                        let diagonal_value = matrix[y-1][x-1];   
                        if (diagonal_value <= top_value) {
                            if (diagonal_value <= left_value) {
                                if (x != div_amount_x && y != div_amount_y) {
                                    path.push({x_coord: x, y_coord: y-1, bottom_left: true});
                                    path.push({x_coord: x-1, y_coord: y, top_right: true});
                                }
                                x--;
                                y--;
                            }
                            else x--;
                        }
                        else if (left_value <= top_value) x--;
                        else y--;
                    }
                }
                let min_max_per_block = new Array(lvl2array2.length);
                min_max_per_block[0] = [0, lvl2array2[0].length - 1];
                for (var i = 1; i < lvl2array2.length; i++) min_max_per_block[i] = [min_max_per_block[i-1][1] + 1, min_max_per_block[i-1][1] + lvl2array2[i].length];
                let absolute_y_per_block = new Array(lvl2array1.length);
                absolute_y_per_block[0] = [0, lvl2array1[0].length - 1];
                for (var i = 1; i < lvl2array1.length; i++) absolute_y_per_block[i] = [absolute_y_per_block[i-1][1] + 1, absolute_y_per_block[i-1][1] + lvl2array1[i].length];
                for (var coords of path) for (var i = absolute_y_per_block[coords.y_coord][0]; i <= absolute_y_per_block[coords.y_coord][1]; i++) {
                    dict.min_max[i].min = Math.min(dict.min_max[i].min, min_max_per_block[coords.x_coord][0]);
                    dict.min_max[i].max = Math.max(dict.min_max[i].max, min_max_per_block[coords.x_coord][1]);
                }

            }
        }

        /**
         * Calculates the Levenshtein distance matrix in a dict.
         * @param {string[]} text_array1 - The full word array of text 1 (y axis)
         * @param {string[]} text_array2 - The full word array of text 2 (x axis)
         * @param {dict} dict - The dict needs to have its min_max array already filled
         * @param {alignmentOptions} alignment_options
        */
        function calculate_and_propagate(text_array1, text_array2, dict, alignment_options) {
            for (var y = 0; y < dict.min_max.length; y++) for (var x = dict.min_max[y].min; x <= dict.min_max[y].max; x++) {
                let left = (x == 0) ? y + 2 : (x == dict.min_max[y].min) ?  Infinity : dict[dkey(x-1, y)] + 1;
                let top  = (y == 0) ? x + 2 : (x > dict.min_max[y-1].max) ? Infinity : dict[dkey(x, y-1)] + 1;
                let diagonal = (y == 0 && x == 0) ? 0 : (y == 0) ? x + 1 : (x == 0) ? y + 1 : (x - 1 > dict.min_max[y-1].max || x - 1 < dict.min_max[y-1].min) ? Infinity : dict[dkey(x-1, y-1)] + 2 * (score(text_array1[y], text_array2[x], {typecase: ((alignment_options.typecase) ? 0 : 0.1), diacritics: ((alignment_options.diacritics) ? 0 : 0.2)}));
                dict[dkey(x, y)] = Math.min(left,top,diagonal);
            }
        }

        /**
         * Creates a dictionary to store a Levensthein distance matrix.
         * @param {string[]} text_array1 - Array of words
         * @param {string[]} text_array2 - Array of words
         * @param {alignmentOptions} alignment_options
         * @returns {dict}
        */
        function create_dict (text_array1, text_array2, alignment_options) {
            var cost_dict = {min_max: new Array(text_array1.length)};
            for (var i = 0; i < text_array1.length; i++) cost_dict.min_max[i] = {min: Infinity, max: -Infinity};
            make_dict_boundaries(text_array1, text_array2, cost_dict, 50, 160000);
            calculate_and_propagate(text_array1, text_array2, cost_dict, alignment_options);
            return cost_dict;
        }

        /**
         * Returns an array of result blocks corresponding to the best path available.
         * @param {!dict} dict - The fully propagated dictionary used
         * @param {!string[]} text_array1 - The full word array for text 1 (on the y axis)
         * @param {!string[]} text_array2 - The full word array for text 2 (on the x axis)
         * @param {alignmentOptions} alignment_options
         * @returns {wordblock[]}
        */
        function make_out_path(dict, text_array1,text_array2, alignment_options) {   
            let result_array = new Array();
            let x = text_array2.length - 1;
            let y = text_array1.length - 1;
            let score_options = {typecase: ((alignment_options.typecase) ? 0 : 0.1), diacritics:((alignment_options.diacritics) ? 0 : 0.2), scale: [0, 0.9]};
            while (x >= -1 && y >= -1) {
                if (x <= -1) {
                    if (y <= -1) break;
                    for (var i = y; i >= 0; i--) result_array.push({label: 2, left: text_array1[i], right: ""});
                    break;
                }
                if (y <= -1) {
                    for (var i = x; i >= 0; i--) result_array.push({label: 3, left: "", right: text_array2[i]});
                    break;
                }
                let diagonal_value = (dkey(x-1, y-1) in dict) ? dict[dkey(x-1, y-1)] : null;
                let left_value = (dkey(x-1, y) in dict) ? dict[dkey(x-1, y)] : null;
                let top_value = (dkey(x, y-1) in dict) ?  dict[dkey(x, y-1)] : null;
                if (left_value==null && top_value==null) {
                    result_array.push({label: score(text_array1[y], text_array2[x], score_options), left: text_array1[y], right: text_array2[x]});
                    x--;
                    y--;
                    continue;
                }
                if (left_value == null) {
                    result_array.push({label: 2, left: text_array1[y], right: ""});
                    y--;
                    continue;
                }
                if (top_value == null) {
                    result_array.push({label: 3, left: "", right: text_array2[x]});
                    x--;
                    continue;
                }
                if (diagonal_value <= left_value && diagonal_value <= top_value) {
                    let new_label = score(text_array1[y], text_array2[x], score_options);
                    if (new_label < 1) {
                        result_array.push({label: new_label, left: text_array1[y], right: text_array2[x]});
                        x--;
                        y--;
                    } else if (left_value < top_value) {
                        result_array.push({label: 3, left: "", right: text_array2[x]});
                        x--;
                    } else {
                        result_array.push({label: 2, left: text_array1[y], right: ""});
                        y--;
                    }
                } else if (left_value < top_value) {
                    result_array.push({label: 3, left: "", right: text_array2[x]});
                    x--;
                } else {
                    result_array.push({label: 2, left: text_array1[y], right: ""});
                    y--;
                }
            }
            return result_array;
        }

        /**
         * Fuses blocks of similar nature and adds punctuation.
         * @param {wordblock[]} text_array - The non-fused path
         * @param {string} text1 - The full first text (on the y axis)
         * @param {string} text2 - The full second text (on the x axis)
         * @param {alignmentOptions} alignment_options
         * @returns {wordblock[]}
        */
        function alt_bring_text_back(text_array, text1, text2, alignment_options) {
            /** @type {wordblock[]} */
            let result_array = new Array(0);
            if (alignment_options.punct) {
                let punct_array_1 = string_to_punct(text1);
                let punct_array_2 = string_to_punct(text2);
                let pt_1 = 0;
                let pt_2 = 0;
                if (string_to_punct(string_interlace(text1)[0]).length != 0) {
                    result_array.push({label: 4, left: punct_array_1[pt_1], right: ""});
                    pt_1++;
                }
                if (string_to_punct(string_interlace(text2)[0]).length != 0) {
                    result_array.push({label: 4, left: "", right: punct_array_2[pt_2]});
                    pt_2++;
                }
                for (var block of text_array) {
                    result_array.push(block);
                    if ((block.label != 3) && (pt_1 < punct_array_1.length)) {result_array.push({label:4, left: punct_array_1[pt_1], right: ""}); pt_1++;}
                    if ((block.label != 2) && (pt_2 < punct_array_2.length)) {result_array.push({label:4, left: "", right: punct_array_2[pt_2]}); pt_2++;}
                }
                return result_array;
            }
            return text_array;
        }

        /**
         * Converts a number to a class list string.
         * @param {number} typeint - 0 if unchanged, 2 if removed, 3 if added, 4 if punctuation, 1 if parallel but non corresponding, between 0 and 1 if changed
         * @returns {string}
        */
        function int_to_type(typeint) {
            if (typeint==0) return "unchanged";
            if (typeint==2) return "removed";
            if (typeint==3) return "added";
            if (typeint==4) return "punct";
            if (typeint==0.1) return "changed typecase";
            if (typeint==0.2) return "changed diacritics";
            if (typeint==0.3) return "changed typecase diacritics";
            if (typeint==1) return "non_corresponding"
            return "changed";
        }

        /**
         * Creates spans in the result display panels.
         * @param {wordblock[]} text_array - The path
        */
        function make_spans(text_array) {
            let span_id = 0;
            for (var block of text_array) {
                span_id++;
                let classes = int_to_type(block.label).split(" ");
                if (block.label != 3) {
                    let new_span_left = document.createElement("span");
                    new_span_left.classList.add("text_part", classes);
                    new_span_left.id = "l_" + span_id;
                    new_span_left.textContent = block.left;
                    document.getElementById("left_panel").appendChild(new_span_left);
                }
                if (block.label != 2) {
                    let new_span_right = document.createElement("span");
                    new_span_right.classList.add("text_part", classes);
                    new_span_right.id = "r_" + span_id;
                    new_span_right.textContent = block.right;
                    document.getElementById("right_panel").appendChild(new_span_right);
                }
            }
        }

        /**
         * Changes the page setup to display the loading screen.
        */
        function change_to_loading_screen() {
            document.querySelectorAll("textarea").forEach(element => {
                element.style.display = "none";
            });
            document.querySelector("#align_button").style.display = "none";
            document.querySelectorAll(".checkbox_container").forEach(element => {
                element.style.display = "none"
            });
        }

        /**
         * Changes the page setup to display the results.
        */
        function change_to_result_screen() {
            document.querySelectorAll(".panel").forEach(element => {
                element.style.display = "block";
            });
        }

        /**
         * Function tied to a span, clicking on this span scrolls it and its 'parallel' span in the middle of the display panels.
         * @param {string} block_id - The id of the span, with format [1-9][0-9]*
        */
        function scroll_to_id(block_id) {
            let offsetHeight = document.querySelector("#left_panel").clientHeight / 2;
            document.querySelector("#left_panel").scrollTop = document.querySelector("#l_"+block_id).offsetTop - offsetHeight;
            document.querySelector("#right_panel").scrollTop = document.querySelector("#r_"+block_id).offsetTop - offsetHeight;
        }

        /**
         * Adds the "click" event listener to call the scroll_to_id function on the spans.
         * @param {Element} span
        */
        function add_scroller_listener(span) {
            if (span.classList.includes("removed") || span.classList.includes("added") || span.classList.includes("punct") || span.classList.includes("non_corresponding")) return;
            var id_array = span.id.split('_');
            span.addEventListener("click", function() {scroll_to_id(id_array[1]);});
        }

        document.addEventListener("DOMContentLoaded", function(){
            /** @type {alignmentOptions} */
            var alignment_options = {
                typecase: false,
                diacritics: false,
                punct: true
            };
            document.querySelector("#punct_check").addEventListener("change", (event) => {
                if (event.currentTarget.checked) alignment_options.punct = true;
                else alignment_options.punct = false;
            });
            document.querySelector("#typecase_check").addEventListener("change", (event) => {
                if (event.currentTarget.checked) alignment_options.typecase = true;
                else alignment_options.typecase = false;
            });
            document.querySelector("#diacritics_check").addEventListener("change", (event) => {
                if (event.currentTarget.checked) alignment_options.diacritics = true;
                else alignment_options.diacritics = false;
            });
            document.querySelectorAll(".panel").forEach(element => {element.style.display = "none";});
            document.querySelector("#align_button").addEventListener("click",function(){
                /** @type {string} */
                var left_text = document.querySelector("#left_textarea").value;
                /** @type {string} */
                var right_text = document.querySelector("#right_textarea").value;
                var ta1 = (alignment_options.punct) ? string_to_words(left_text) : string_interlace(left_text);
                var ta2 = (alignment_options.punct) ? string_to_words(right_text) : string_interlace(right_text);
                if (ta1.length == 0 || ta2.length == 0) return;
                change_to_loading_screen();
                var levenshtein_dict = create_dict(ta1, ta2, alignment_options);
                var path_ta = make_out_path(levenshtein_dict, ta1, ta2, alignment_options);
                path_ta.reverse();
                path_ta = alt_bring_text_back(path_ta, left_text, right_text, alignment_options);
                make_spans(path_ta);
                change_to_result_screen();
            });
        });
    </script>
</head>
<body>
    <header>
        <div id="logo_div">
            <a href="./index.html" id="logo_anchor">
                <img width="90" height="90" src="./logoIGM-300x298.png" alt="Laboratoire d'Informatique Gaspard-Monge" decoding="async">
            </a>
        </div>
        <div id="titlediv">
            <h1>COATL</h1>
        </div>
        <div id="links">
            <ul id="links_list">
                <li><a href="https://siteigm.univ-mlv.fr/" target="_blank">Site du LIGM</a></li>
                <li><a href="https://github.com/maxB9F/COATL-LIGM" target="_blank">Dépôt Github</a></li>
            </ul>
        </div>
    </header>
    <div class="box" id="outerbox">
        <div class="box" id="innerbox">
            <textarea autocomplete="off" minlength="1" spellcheck="false" id="left_textarea" placeholder="La première version du texte"></textarea>
            <textarea autocomplete="off" minlength="1" spellcheck="false" id="right_textarea" placeholder="La seconde version du texte"></textarea>
            <div class="panel" id="left_panel"></div>
            <div class="panel" id="right_panel"></div>
        </div>
        <div class="box" id="button_box">
            <div class="checkbox_container">
                <input type="checkbox" id="punct_check" checked>
                <label for="punct_check">Ignorer la ponctuation et les séparateurs</label>
            </div>
            <div class="checkbox_container">
                <input type="checkbox" id="typecase_check">
                <label for="typecase_check">Ignorer les différences de casse typographique</label>
            </div>
            <div class="checkbox_container">
                <input type="checkbox" id="diacritics_check">
                <label for="diacritics_check">Ignorer les différences de signes diacritiques</label>
            </div>
            <button id="align_button"  type="button">Align</button>
            <button id="reset_button"  type="button">Reset</button>
            <button id="export_button" type="button">Export</button>
        </div>
    </div>
</body>
</html>